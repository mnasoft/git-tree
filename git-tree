#!/bin/bash

. /etc/git-tree/git-tree.conf

# DEBUG="Yes"
# DEEP="No"

log_colors () {
  BOLD=$(tput bold)
  RESET=$(tput sgr0)
  BLACK=$(tput setaf 0)
  RED=$(tput setaf 1)
  GREEN=$(tput setaf 2)
  YELLOW=$(tput setaf 3)
  BLUE=$(tput setaf 4)
  MAGENTA=$(tput setaf 5)
  CYAN=$(tput setaf 6)
  WHITE=$(tput setaf 7)
  GRAY=$(tput setaf 8)
}

load_git_tree_config () {
  # –û–ø—Ä–µ–¥–µ–ª—è–µ–º –¥–æ–º–∞—à–Ω—é—é –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é –Ω–∞—Å—Ç–æ—è—â–µ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è (–ø–æ–¥–¥–µ—Ä–∂–∫–∞ sudo)
  if [[ -n "$SUDO_USER" ]]; then
    USER_HOME=$(eval echo "~$SUDO_USER")
  else
    USER_HOME="$HOME"
  fi

  CONFIG_DIR="$USER_HOME/.git-tree"
  CONFIG_FILE="$CONFIG_DIR/locations.conf"

  # –ï—Å–ª–∏ –∫–æ–Ω—Ñ–∏–≥ –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç ‚Äî —Å–æ–∑–¥–∞—ë–º —Å —à–∞–±–ª–æ–Ω–æ–º
  if [[ ! -f "$CONFIG_FILE" ]]; then
    echo "üìÑ –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–æ–Ω–Ω—ã–π —Ñ–∞–π–ª –Ω–µ –Ω–∞–π–¥–µ–Ω. –°–æ–∑–¥–∞—é —à–∞–±–ª–æ–Ω: $CONFIG_FILE"
    mkdir -p "$CONFIG_DIR"
    cat > "$CONFIG_FILE" <<EOF
# ~/.git-tree/locations.conf
# üóÇÔ∏è –°–ø–∏—Å–æ–∫ –ª–æ–∫–∞—Ü–∏–π –¥–ª—è —Å–∏—Å—Ç–µ–º—ã git-tree

LOCATIONS=()

# üí° –ü—Ä–∏–º–µ—Ä—ã:
# LOCATIONS+=('gh')
# NAME_gh='GitHub'
# CUSTOM_URL_GIT[gh]="git@github.com:username/repo.git"
EOF
  fi

  # –ü–æ–¥–∫–ª—é—á–∞–µ–º —Ñ–∞–π–ª
  source "$CONFIG_FILE"
}

# üìö –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö NAME_*, URL_GIT_*, URL_XZ_*, TAR_* 
init_location_vars () {
    log_full_trace
    
    for loc in "${LOCATIONS[@]}"
    do
        # üè∑Ô∏è NAME_<loc>: –µ—Å–ª–∏ –Ω–µ –∑–∞–¥–∞–Ω–æ ‚Äî –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é –∏–º—è –∫–∞–∫ id
        if ! declare -p "NAME_${loc}" &>/dev/null; then
            eval "NAME_${loc}='${loc}'"
        fi
        
        # üîó URL_GIT_<loc>: –∫–∞—Å—Ç–æ–º –∏–ª–∏ —à–∞–±–ª–æ–Ω
        if [[ -n "${CUSTOM_URL_GIT[$loc]:-}" ]]
        then
            # –∫–∞—Å—Ç–æ–º–Ω—ã–π URL –∏–∑ –º–∞—Å—Å–∏–≤–∞ –µ—Å—Ç—å –∏ –Ω–µ–ø—É—Å—Ç–æ–π
            eval "URL_GIT_${loc}='${CUSTOM_URL_GIT[$loc]}'"
        else
            # –∫–∞—Å—Ç–æ–º–Ω–æ–≥–æ –Ω–µ—Ç ‚Äî –∏—Å–ø–æ–ª—å–∑—É–µ–º —à–∞–±–ª–æ–Ω
            eval "URL_GIT_${loc}=\"\${URL_GIT_TREE}/git/${loc}\""
        fi

        # üì¶ URL_XZ_<loc>: –≤—Å–µ–≥–¥–∞ –ø–æ —à–∞–±–ª–æ–Ω—É, –µ—Å–ª–∏ –Ω–µ –∑–∞–¥–∞–Ω–æ
        if ! declare -p "URL_XZ_${loc}" &>/dev/null; then
            eval "URL_XZ_${loc}=\"\${URL_GIT_TREE}/xz/${loc}\""
        fi

        # üéÅ TAR_<loc>: —Ñ–æ—Ä–º–∏—Ä—É–µ–º –∏–º—è –∞—Ä—Ö–∏–≤–∞ ‚Äî <name>.tar
        if ! declare -p "TAR_${loc}" &>/dev/null; then
            name_var="NAME_${loc}"
            eval "TAR_${loc}=\"\${${name_var}}.tar\""
        fi
        var="URL_GIT_${loc}"
        echo "${!var}"  # üëç –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π —Å–ø–æ—Å–æ–±

    done
}

# üõ†Ô∏è –°–æ–∑–¥–∞–Ω–∏–µ –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã—Ö –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–π
init_git_tree_structure () {
  mkdir -p "${URL_GIT_TREE}/git" "${URL_GIT_TREE}/xz"

  for loc in "${LOCATIONS[@]}"; do
    mkdir -p "$(eval echo "\${URL_GIT_${loc}}")"
    mkdir -p "$(eval echo "\${URL_XZ_${loc}}")"
  done
}

log_full_trace () {
  if [[ "$DEBUG" != "Yes" ]]; then return; fi

  local stack_size=${#FUNCNAME[@]}
  local argv_index=0
  local depth
  if [[ "$DEEP" == "Yes" ]]
  then depth=$stack_size
  else depth=2
  fi
  echo "üìä –õ–æ–≥ –≤—ã–∑–æ–≤–∞ —Ñ—É–Ω–∫—Ü–∏–π (–≥–ª—É–±–∏–Ω–∞: $((depth - 1))):"

  for (( level = 1; level < depth; level++ )); do
    local func="${FUNCNAME[level]}"
    local argc="${BASH_ARGC[level-1]:-0}"

    echo "üîπ –£—Ä–æ–≤–µ–Ω—å $level: —Ñ—É–Ω–∫—Ü–∏—è '$func' —Å $argc –∞—Ä–≥—É–º–µ–Ω—Ç–∞–º–∏:"

    for (( i = 0; i < argc; i++ )); do
      echo "    ‚û§ \$${i} = '${BASH_ARGV[argv_index]}'"
      ((argv_index++))
    done
  done
}

echo_short ()
{
    # echo '--------------------'
    cd .
}

echo_long ()
{
    # echo '---------------------------------'
    cd .
}

echo_long_plus ()
{
    # echo '+++++++++++++++++++++++++++++++++'
    cd .
}

echo_long_equal ()
{
    echo '================================================================================'
}

check_dir_public_html_clp_arch ()
{
    echo "<<< mkdir -p ${PUB_HTML_CLP_ARH} >>>"
    mkdir -p ${PUB_HTML_CLP_ARH}
}

make_repo_vars ()
{
    NAME="NAME_${LOCATION}"
    URL_GIT="URL_GIT_${LOCATION}"
    URL_XZ="URL_XZ_${LOCATION}"
    TAR="TAR_${LOCATION}"
}

check_dir_git ()
{
    make_repo_vars
    echo "<<< mkdir -p ${!URL_GIT} >>>"
    mkdir -p ${!URL_GIT}
}

check_dir_xz ()
{
    make_repo_vars
    echo "<<< mkdir -p ${!URL_XZ} >>>"    
    mkdir -p ${!URL_XZ}
}

rm_git ()
{
    make_repo_vars
    echo "<<< rm -rf ${!URL_GIT}/*.git >>>"    
    rm -rf ${!URL_GIT}/*.git
}

remove_xz ()
{
    make_repo_vars 
    echo "<<< rm -f ${!URL_XZ}/*.git.tar.xz >>>"
    rm -f ${!URL_XZ}/*.git.tar.xz
}

make_git ()
{
    CDIR=`pwd`
    make_repo_vars
    
    for i in `find . -name "*.git"`
    do
        cd $i/..
        if [[ `git remote | grep ${LOCATION}` ]]
        then
            NAME=`pwd`
            BNAME=`basename $NAME`
            echo $i
            echo $NAME
            echo ${BNAME}
            cd ..
            echo "<<< git clone --bare ${BNAME} ${!URL_GIT}/${BNAME}.git >>>"
            git clone --bare ${BNAME} ${!URL_GIT}/${BNAME}.git
        else
            cd ..
        fi
        cd ${CDIR}
    done
}

info ()
{
    make_repo_vars
    echo LOCATION=${LOCATION}
    echo "NAME_${LOCATION}=${!NAME}"
    echo "URL_GIT_${LOCATION}=${!URL_GIT}"
    echo "URL_XZ_${LOCATION}=${!URL_XZ}"
    echo "TAR_${LOCATION}=${!TAR}"    
}

remake_xz ()
{
    remove_xz
    check_dir_xz
    make_repo_vars
    cd ${!URL_GIT}
    for i in `find . -name "*.git"`
    do
        BNAME=`basename $i`
        echo $i
        echo ${BNAME}
        echo "<<< tar -cvvJf ${BNAME}.tar.xz ${BNAME}/ >>>"
        tar -cvvJf ${BNAME}.tar.xz ${BNAME}/
        echo "<<< mv ${BNAME}.tar.xz ${!URL_XZ}/ >>>"
        mv ${BNAME}.tar.xz ${!URL_XZ}/
    done
}

remake_git ()
{
    rm_git

    echo "<<< cd ${HOME}/quicklisp/local-projects/ >>>"
    cd ${HOME}/quicklisp/local-projects/
    make_git

    echo "<<< cd ${HOME}/develop/ >>>"
    cd ${HOME}/develop/
    make_git

    echo "<<< cd ${HOME}/elisp/ >>>"
    cd ${HOME}/elisp/
    make_git
}

remake_tar_xz ()
{
    check_dir_public_html_clp_arch
    remake_xz
    make_repo_vars

    echo "<<< cd ${!URL_XZ} >>>"
    cd ${!URL_XZ}

    echo "<<< tar -cvvf ${!TAR} *.git.tar.xz >>>"
    tar -cvvf ${!TAR} *.git.tar.xz
    
    echo "<<< mv -f ${!TAR} ${URL_GIT_TREE} >>>"
    mv -f ${!TAR} ${URL_GIT_TREE}
}

GIT_TREE_USAGE="
NAME
        $(basename $0) –≤—ã–ø–æ–ª–Ω—è–µ—Ç –æ–¥–Ω–æ—Ç–∏–ø–Ω—ã–µ –æ–ø–µ—Ä–∞—Ü–∏–∏ –Ω–∞–¥ —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏—è–º–∏
                 git, —Ä–∞—Å–ø–æ–ª–æ–∂–µ–Ω–Ω—ã–º–∏ –≤ –¥–µ—Ä–µ–≤–µ –∫–∞—Ç–∞–ª–æ–≥–æ–≤.

SYNOPSIS
        $(basename $0) [ pull | push | pullsh | all [<branch>]]   |
                 [ commit | add]                            |
                 [ readd         [ ${LOCATIONS[*]} ] |
                 [ update        [ ${LOCATIONS[*]} ] |
                 [ rm            [ ${LOCATIONS[*]} ] |
                 [ clone         [ ${LOCATIONS[*]} ] |
                 [ info          [ ${LOCATIONS[*]} ] |
                 [ make_git      [ pp | pz ]]   |
                 [ xz_git        [ pp | pz ]]   |
                 [ remake_git    [ pp | pz ]]   |
                 [ remake_tar_xz [ pp | pz ]]    

        $(basename $0) [quicklisp] | [pacman] | [dot_emacs_d] | [add_aliases] |
                 [rs_local_pi | rs_pi_local | rs_pi_html] |
                 [reclone]


DESCRIPTION
    –§–æ—Ä–º–∞ 1:
        –í—ã–ø–æ–ª–Ω—è–µ—Ç –ø–æ–∏—Å–∫ —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–µ–≤ git, –Ω–∞—á–∏–Ω–∞—è —Å —Ç–µ–∫—É—â–µ–≥–æ
        –∫–∞—Ç–∞–ª–æ–≥–∞. –î–ª—è –∫–∞–∂–¥–æ–≥–æ –Ω–∞–π–¥–µ–Ω–Ω–æ–≥–æ —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏—è git –≤—ã–ø–æ–ª–Ω—è–µ—Ç
        —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â—É—é –∫–æ–º–∞–Ω–¥—É.
    –§–æ—Ä–º–∞ 2:
        –í—ã–ø–æ–ª–Ω—è–µ—Ç —Å–æ–æ–≤–µ—Ç—Å—Ç–≤—É—é—â—É—é –∫–æ–º–∞–Ω–¥—É.

OPTIONS 
        <branch> –∑–∞–¥–∞–µ—Ç –≤–µ—Ç–∫—É, –ø–æ–ª—É—á–∞–µ–º—É—é|–æ—Ç–ø—Ä–∞–≤–ª—è–µ–º—É—é –Ω–∞ —É–¥–∞–ª–µ–Ω–Ω—ã–µ
            —Å–µ—Ä–≤–µ—Ä–∞. –ï—Å–ª–∏ –Ω–µ —É–∫–∞–∑–∞–Ω–∞ –æ–ø–µ—Ä–∞—Ü–∏—è –≤—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è —Å —Ç–µ–∫—É—â–µ–π
            –≤–µ—Ç–∫–æ–π.

COMMANDS
        pull      - –ø–æ–ª—É—á–µ–Ω–∏–µ –∏–∑–º–µ–Ω–µ–Ω–∏–π —Å —Å–µ—Ä–≤–µ—Ä–∞;
        push      - –æ—Ç–ø—Ä–∞–≤–∫–∞ –∏–∑–º–µ–Ω–µ–Ω–∏–π –Ω–∞ —Å–µ—Ä–≤–µ—Ä;
        pullsh    - –ø–æ–ª—É—á–µ–Ω–∏–µ –∏ –æ—Ç–ø—Ä–∞–≤–∫–∞ –∏–∑–º–µ–Ω–µ–Ω–∏–π;
        add       - –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ –∏–∑–º–µ–Ω–µ–Ω–∏–π;
        commit    - —Ñ–∏–∫—Å–∞—Ü–∏—è –∏–∑–º–µ–Ω–µ–Ω–∏–π;
        all       - –ø–æ–ª—É—á–µ–Ω–∏–µ –∏–∑–º–µ–Ω–µ–Ω–∏–π —Å —Å–µ—Ä–≤–µ—Ä–∞, –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ –∏–∑–º–µ–Ω–µ–Ω–∏–π,
                    —Ñ–∏–∫—Å–∞—Ü–∏—è –∏–∑–º–µ–Ω–µ–Ω–∏–π, –æ—Ç–ø—Ä–∞–≤–∫–∞ –∏–∑–º–µ–Ω–µ–Ω–∏–π –Ω–∞ —Å–µ—Ä–≤–µ—Ä;

    –£–¥–∞–ª–µ–Ω–∏–µ –∏ –ø–æ–≤—Ç–æ—Ä–Ω–æ–µ –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ —É–¥–∞–ª–µ–Ω–Ω–æ–≥–æ —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏—è:
        readd     - –≤ —Ä–∞–∑–º–µ—â–µ–Ω–∏–µ [ ${LOCATIONS[*]} ];

    –£–¥–∞–ª–µ–Ω–∏–µ –∏ –ø–æ–≤—Ç–æ—Ä–Ω–æ–µ –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ —É–¥–∞–ª–µ–Ω–Ω–æ–≥–æ —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏—è –µ—Å–ª–∏ –æ–Ω
    —Å—É—â–µ—Å—Ç–≤—É–µ—Ç:
        update - –≤ —Ä–∞–∑–º–µ—â–µ–Ω–∏–µ [ ${LOCATIONS[*]} ];

    –£–¥–∞–ª–µ–Ω–∏–µ —É–¥–∞–ª–µ–Ω–Ω–æ–≥–æ —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏—è:
        rm        -  –≤ —Ä–∞–∑–º–µ—â–µ–Ω–∏–µ [ ${LOCATIONS[*]} ];

    –ö–ª–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–µ—Ä–µ–≤–∞ —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–µ–≤:
        clone     - –≤ —Ä–∞–∑–º–µ—â–µ–Ω–∏–µ [ ${LOCATIONS[*]} ];

    –°–æ–∑–¥–∞–Ω–∏–µ —á–∏—Å—Ç—ã—Ö —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–µ–≤ git:
        make_git :
            $URL_GIT_pw –¥–ª—è —Ä–∞—Å–ø–æ–ª–æ–∂–µ–Ω–∏—è pw;
            $URL_GIT_pp –¥–ª—è —Ä–∞—Å–ø–æ–ª–æ–∂–µ–Ω–∏—è pp;
            $URL_GIT_pz –¥–ª—è —Ä–∞—Å–ø–æ–ª–æ–∂–µ–Ω–∏—è pz;

        remake_git - —É–¥–∞–ª—è–µ—Ç –∏ —Å–æ–∑–¥–∞–µ—Ç –ø–æ–≤—Ç—Ä–æ–Ω–æ –¥–ª—è: —Ä–∞—Å–ø–æ–ª–æ–∂–µ–Ω–∏—è pp –≤
            –∫–∞—Ç–∞–ª–æ–≥–µ $URL_GIT_pp; —Ä–∞—Å–ø–æ–ª–æ–∂–µ–Ω–∏—è pz –≤ –∫–∞—Ç–∞–ª–æ–≥–µ
            $URL_GIT_pz —á–∏—Å—Ç—ã–µ —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–∏ git, –Ω–∞—Ö–æ–¥—è—â–∏–µ—Å—è –≤
            –∫–∞—Ç–∞–ª–æ–≥–∞—Ö:
            - ${HOME}/quicklisp/local-projects/;
            - ${HOME}/develop/;
            - ${HOME}/elisp/;

        remake_xz - —É–¥–∞–ª—è–µ—Ç –∏ –ø–æ–≤—Ç–æ—Ä–Ω–æ —Å–æ–∑–¥–∞–µ—Ç:
            - –¥–ª—è —Ä–∞—Å–ø–æ–ª–æ–∂–µ–Ω–∏—è pp –≤ –∫–∞—Ç–∞–ª–æ–≥–µ
            $URL_XZ_pp
            - –¥–ª—è —Ä–∞—Å–ø–æ–ª–æ–∂–µ–Ω–∏—è pz –≤ –∫–∞—Ç–∞–ª–æ–≥–µ
            $URL_XZ_pz 
            –∞—Ä—Ö–∏–≤—ã .tar.xz —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–µ–≤ git, –Ω–∞—Ö–æ–¥—è—â–∏—Ö—Å—è –≤ –∫–∞—Ç–∞–ª–æ–≥–µ 
            $URL_GIT_pp;
            $URL_GIT_pz
            —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ;

        remake_tar_xz :
            - –¥–ª—è —Ä–∞—Å–ø–æ–ª–æ–∂–µ–Ω–∏—è pp —Å–æ–∑–¥–∞–µ—Ç –∞—Ä—Ö–∏–≤ ${TAR_pp} –∏–∑
              —Ñ–∞–π–ª–æ–≤ —Å —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ–º .git.tar.xz, –Ω–∞—Ö–æ–¥—è—â–∏—Ö—Å—è –≤ –∫–∞—Ç–∞–ª–æ–≥–µ
              ${URL_XZ_pp};
            - –¥–ª—è —Ä–∞—Å–ø–æ–ª–æ–∂–µ–Ω–∏—è pz —Å–æ–∑–¥–∞–µ—Ç –∞—Ä—Ö–∏–≤ ${TAR_pz} –∏–∑
              —Ñ–∞–π–ª–æ–≤ —Å —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ–º .git.tar.xz, –Ω–∞—Ö–æ–¥—è—â–∏—Ö—Å—è –≤ –∫–∞—Ç–∞–ª–æ–≥–µ
              ${URL_XZ_pz}, –∏ –ø–µ—Ä–µ–º–µ—â–∞–µ—Ç –µ–≥–æ –≤ –∫–∞—Ç–∞–ª–æ–≥
              ${PUB_HTML_CLP_ARH};

        rs_local_pi : –í—ã–ø–æ–ª–Ω—è–µ—Ç —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—é –ø–∞–ø–∫–∏ ~/public_html/ —Å
	     mnasoft.ddns.mksat.net;

        rs_pi_local : –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è mnasoft.ddns.mksat.net —Å –ø–∞–ø–∫–æ–π
             ~/public_html;

        rs_pi_html : –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –ø–∞–ø–∫–∏
             ~/public_html/Common-Lisp-Programs/ —Å —Å–µ—Ä–≤–µ—Ä–æ–º
             mnasoft.ddns.mksat.net;

    –†–∞—Å–ø–∞–∫–æ–≤–∫–∞ –∞—Ä—Ö–∏–≤–æ–≤ git.tar.xz –≤ –∫–∞—Ç–∞–ª–æ–≥–∏ —Å —á–∏—Å—Ç—ã–º–∏ —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏—è–º–∏
    –¥–ª—è —Ä–∞—Å–ø–æ–ª–æ–∂–µ–Ω–∏—è:
        xz_git - pp –∏ pp;
    
        quicklisp - —Å–æ–∑–¥–∞–µ—Ç –≤ –∫–∞—Ç–∞–ª–æ–≥–µ ${PUB_HTML_CLP_ARH} —Ñ–∞–π–ª quicklisp.tar.xz,
            —Å–æ–¥–µ—Ä–∂–∞—â–∏–π –¥–∞–Ω–Ω—ã–µ –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è quicklisp;
    
        pacman - –∫–æ–ø–∏—Ä—É–µ—Ç –≤ –∫–∞–∫–∞–ª–æ–≥ ${PUB_HTML_CLP_ARH} –ø–∞–∫–µ—Ç–æ–≤ –∏ —Ñ–∞–π–ª–æ–≤
            —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏, –Ω–µ–æ–±—Ö–æ–¥–∏–º—è—Ö –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è msys2;
    
        dot_emacs_d - –∫–æ–ø–∏—Ä—É–µ—Ç –≤ –∫–∞–∫–∞–ª–æ–≥ ${PUB_HTML_CLP_ARH} —Ñ–∞–π–ª–æ–≤ –∏–∑
             –∫–∞—Ç–∞–ª–æ–≥–∞ .emacs.d;
    
        add_aliases - –¥–æ–±–∞–≤–ª—è–µ—Ç –∞–±–±—Ä–µ–≤–∏–∞—Ç—É—Ä—ã –¥–ª—è –∑–∞–ø—É—Å–∫–∞ –∫–æ–º–∞–Ω–¥ git.
"

show_usage ()
{
    echo "${GIT_TREE_USAGE}"
}

push ()
{
    for rpo in `git remote`
    do
        echo_short

        echo "<<< git push ${rpo} ${DO_BRANCH} >>>"
        git push ${rpo} ${DO_BRANCH}
        
        echo_short
    done
}

pull ()
{
    for rpo in `git remote`
    do
        echo_short
        
        echo "<<< git pull ${rpo} ${DO_BRANCH} >>>"
        git pull ${rpo} ${DO_BRANCH}
        
        echo_short
    done
}

add ()
{
    log_full_trace
    
    echo_short

    echo "<<< git add `find . -name "*.lisp" -o -name "*.org" -o -name "*.asd" -o -name "*.c*" -o -name "*.h*" -o -name "*.tcl*" -o -name ".gitignore"` >>>"
    git add `find . -name "*.lisp" -o -name "*.org" -o -name "*.asd" -o -name "*.c*" -o -name "*.h*" -o -name "*.tcl*" -o -name ".gitignore"`
# -o -name "*.scr" 
    
    echo_short
}

readd ()
{
    log_full_trace
    
    echo_short
    make_repo_vars
    
    echo "<<< git remote remove ${!NAME} >>>"
    git remote remove ${!NAME}
    
    DIR_REPO=`pwd`
    REPO=`basename ${DIR_REPO}`
    
    echo "<<< git remote add ${!NAME} ${!URL_GIT}/${REPO}.git >>>"
    git remote add ${!NAME} ${!URL_GIT}/${REPO}.git

    echo_short
}

readd () {
    log_full_trace
    echo_short
    make_repo_vars
    log_colors

    name="${!NAME}"
    dir_repo=$(pwd)
    repo=$(basename "$dir_repo")
    remote_url="${!URL_GIT}/${repo}.git"

    echo "${CYAN}üîç –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤–Ω–µ—à–Ω–µ–≥–æ —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏—è: ${BOLD}${name}${RESET}"
    if git remote get-url "$name" &>/dev/null; then
        echo "${YELLOW}üóë  –£–¥–∞–ª–µ–Ω–∏–µ –≤–Ω–µ—à–Ω–µ–≥–æ —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏—è:${RESET} ${name}"
        git remote remove "$name"
    else
        echo "${GRAY}‚ö†  –í–Ω–µ—à–Ω–∏–π '${name}' –Ω–µ –ø–æ–¥–∫–ª—é—á—ë–Ω ‚Äî –ø—Ä–æ–ø—É—Å–∫–∞–µ–º —É–¥–∞–ª–µ–Ω–∏–µ${RESET}"
    fi

    echo "${GREEN}‚ûï –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –≤–Ω–µ—à–Ω–µ–≥–æ —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏—è:${RESET} ${name}"
    echo "   ${CYAN}‚Üí $remote_url${RESET}"
    git remote add "$name" "$remote_url"

    echo_short
}


update ()
{
    make_repo_vars
    for i in `git remote`
    do
        if [[ ${!NAME} == $i ]]
        then
            git tree readd $i
        fi
    done
}

git_rm () {
    make_repo_vars
    log_colors

    name="${!NAME}"

    echo "${CYAN}üîç –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤–Ω–µ—à–Ω–µ–≥–æ —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏—è: ${BOLD}${name}${RESET}"
    if git remote get-url "$name" &>/dev/null; then
        echo "${YELLOW}üóëÔ∏è –£–¥–∞–ª–µ–Ω–∏–µ –≤–Ω–µ—à–Ω–µ–≥–æ —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏—è:${RESET} ${name}"
        git remote remove "$name"
    else
        echo "${GRAY}‚ö† –í–Ω–µ—à–Ω–∏–π —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–π '${name}' –Ω–µ –Ω–∞–π–¥–µ–Ω ‚Äî —É–¥–∞–ª–µ–Ω–∏–µ –Ω–µ —Ç—Ä–µ–±—É–µ—Ç—Å—è${RESET}"
    fi
    echo_short
}

git_clone () {
    log_colors
    echo_short
    make_repo_vars

    if git remote | grep -q "${LOCATION}"; then
        dir_path=$(pwd)
        repo_name=$(basename "$dir_path")
        clone_url="${!URL_GIT}/${repo_name}.git"

        echo "${CYAN}üì§ –ö–ª–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ bare-—Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏—è ‚Üí ${clone_url}${RESET}"
        echo "${GRAY}‚Ü≥ –ö–æ–º–∞–Ω–¥–∞: git clone --bare . ${clone_url}${RESET}"
        if git clone --bare . "${clone_url}"; then
            echo "${GREEN}‚úÖ –†–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–π '${repo_name}' —Å–∫–ª–æ–Ω–∏—Ä–æ–≤–∞–Ω –∫–∞–∫ bare –≤ –≤–Ω–µ—à–Ω–µ–µ —Ö—Ä–∞–Ω–∏–ª–∏—â–µ${RESET}"
        else
            echo "${RED}‚ùå –û—à–∏–±–∫–∞: –Ω–µ —É–¥–∞–ª–æ—Å—å –∫–ª–æ–Ω–∏—Ä–æ–≤–∞—Ç—å bare-—Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–π –≤ '${clone_url}'${RESET}"
        fi
    else
        echo "${YELLOW}‚ö† –í–Ω–µ—à–Ω–∏–π '${LOCATION}' –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ —Å–ø–∏—Å–∫–µ remotes ‚Äî –æ–ø–µ—Ä–∞—Ü–∏—è –ø—Ä–æ–ø—É—â–µ–Ω–∞${RESET}"
    fi

    echo_short
}



commit ()
{
    echo_short
    echo "<<< git commit -a -m \"`date -u`\" >>>"
    git commit -a -m "`date -u`"
    echo_short
}

commit () {
    log_colors

    timestamp=$(date -u +"%Y-%m-%d %H:%M:%S UTC")
    echo "${CYAN}üì¶ –§–∏–∫—Å–∞—Ü–∏—è –≤—Å–µ—Ö –∏–∑–º–µ–Ω–µ–Ω–∏–π —Å –º–µ—Ç–∫–æ–π:${RESET} ${BOLD}${timestamp}${RESET}"
    echo "${GRAY}‚Ü≥ –ö–æ–º–∞–Ω–¥–∞: git commit -a -m \"${timestamp}\"${RESET}"

    if git commit -a -m "${timestamp}"; then
        echo "${GREEN}‚úÖ –ò–∑–º–µ–Ω–µ–Ω–∏—è –∑–∞—Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω—ã —É—Å–ø–µ—à–Ω–æ${RESET}"
    else
        echo "${YELLOW}‚ö† –ù–µ—á–µ–≥–æ —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞—Ç—å ‚Äî —Ä–∞–±–æ—á–µ–µ –¥–µ—Ä–µ–≤–æ —á–∏—Å—Ç–æ–µ${RESET}"
    fi

    echo_short
}


command_1 ()
{
    echo_short
    echo "<<< $1 $2 $3 $4 $5 $6 $7 $8 $9 >>>"
    $1 $2 $3 $4 $5 $6 $7 $8 $9
    echo_short
}

push_or_pull ()
{
    for rpo in `git remote`
    do
        echo_short

        echo "<<< git ${COMMAND} ${rpo} ${DO_BRANCH} >>>"
        git ${COMMAND} ${rpo} ${DO_BRANCH}

        echo_short
    done
}

push_or_pull () {
    log_colors

    for rpo in $(git remote); do
        echo_short

        echo "${CYAN}üîÅ –í—ã–ø–æ–ª–Ω–µ–Ω–∏–µ: ${BOLD}git ${COMMAND} ${rpo} ${DO_BRANCH}${RESET}"
        echo "${GRAY}‚Ü≥ ${COMMAND^^} ‚Üí —É–¥–∞–ª—ë–Ω–Ω—ã–π '${rpo}' –≤–µ—Ç–∫–∞ '${DO_BRANCH}'${RESET}"

        if git ${COMMAND} "${rpo}" "${DO_BRANCH}"; then
            echo "${GREEN}‚úÖ ${COMMAND^} –¥–ª—è '${rpo}' –≤—ã–ø–æ–ª–Ω–µ–Ω —É—Å–ø–µ—à–Ω–æ${RESET}"
        else
            echo "${RED}‚ùå ${COMMAND^} –¥–ª—è '${rpo}' –∑–∞–≤–µ—Ä—à–∏–ª—Å—è —Å –æ—à–∏–±–∫–æ–π${RESET}"
        fi

        echo_short
    done
}

current_branch ()
{
    CURRENT_BRANCH=`git branch --no-color | grep \*  | cut -d ' ' -f 2`
}

command_branch ()
{
    current_branch
    DO_BRANCH="${CURRENT_BRANCH}"
#    if ! [[ -z "${BRANCH}" ]]
#    then
#        DO_BRANCH="${BRANCH}"
#    else
#        DO_BRANCH="${CURRENT_BRANCH}"
#    fi
    if [[ ${COMMAND} == "push" || ${COMMAND} == "pull" ]]
    then
        push_or_pull
    fi
    if [[ ${COMMAND} == "pullsh" ]]
    then
        pull
        push
    fi
    if [[ ${COMMAND} == "add" ]]
    then
        add
    fi
    if [[ ${COMMAND} == "commit" ]]
    then
        commit
    fi
    if [[ ${COMMAND} == "command" ]]
    then
        command
    fi
    if [[ ${COMMAND} == "all" ]]
    then
        pull
        add
        commit
        push
    fi
    if [[ ${COMMAND} == "readd" ]]
    then
        readd
    fi
    if [[ ${COMMAND} == "update" ]]
    then
        update
    fi
    if [[ ${COMMAND} == "rm" ]]
    then
        git_rm
    fi
    if [[ ${COMMAND} == "clone" ]]
    then
        git_clone
    fi    
}

tree_command ()
{
    CDIR=`pwd`
    for i in `find . -name ".git"`
    do
        echo_long_equal
        cd ${CDIR}/${i}/../
        echo "`pwd`"
        echo_long
        command_branch
        echo_long_plus
    done
    cd ${CDIR}
}

tree_command () {
    log_colors
    echo_short

    local CDIR=$(pwd)
    local git_dirs
    mapfile -t git_dirs < <(find . -type d -name ".git")

    for git_dir in "${git_dirs[@]}"; do
        echo_long_equal

        repo_dir=$(realpath "${CDIR}/${git_dir}/..")
        cd "$repo_dir" || continue

        echo "${CYAN}${BOLD}${repo_dir}${RESET}"
        echo_long

        command_branch

        echo_long_plus
    done

    cd "$CDIR" || return
    echo_short
}

tree_command_1 ()
{
    CDIR=`pwd`
    for i in `find . -name ".git"`
    do
        echo_long_equal
        cd ${CDIR}/${i}/../
        echo "`pwd`"
        echo_long
        command_1 $1 $2 $3 $4 $5 $6 $7 $8 $9
        echo_long_plus
    done
    cd ${CDIR}
}

tree_command_1 () {
    log_colors
    echo_short

    local CDIR=$(pwd)
    local git_dirs
    mapfile -t git_dirs < <(find . -type d -name ".git")

    for git_dir in "${git_dirs[@]}"; do
        echo_long_equal

        repo_dir=$(realpath "${CDIR}/${git_dir}/..")
        cd "$repo_dir" || continue

        echo "${CYAN}${BOLD}${repo_dir}${RESET}"
        echo_long

        command_1 "$@"

        echo_long_plus
    done

    cd "$CDIR" || return
    echo_short
}

rs_quicklisp ()
{
    check_dir_public_html_clp_arch

    cd $HOME/quicklisp/dists
    tar -cvvJf quicklisp.tar.xz ./quicklisp/*.cdb ./quicklisp/*.txt ./quicklisp/archives/
    mv -f quicklisp.tar.xz ${PUB_HTML_CLP_ARH}
}

rs_pacman ()
{
    check_dir_public_html_clp_arch

    if [[ -d "${VAR_CACHE_PACMAN}" ]]
    then
        cd ${VAR_CACHE_PACMAN}
        tar -cvvJf pkg.tar.xz pkg/
        mv -f pkg.tar.xz ${PUB_HTML_CLP_ARH}
    fi

    if [[ -d "${VAR_CACHE_PACMAN}" ]]
    then
        cd ${VAR_LIB_PACMAN}
        tar -cvvJf sync.tar.xz sync/
        mv -f sync.tar.xz ${PUB_HTML_CLP_ARH}
    fi
}

rs_dot_emacs_d_public ()
{
    check_dir_public_html_clp_arch

    echo "<<< cd ${HOME} >>>"
    cd ${HOME}

    echo "<<< tar -cvvJf dot.emacs.d.tar.xz .emacs.d/ >>>"
    tar -cvvJf dot.emacs.d.tar.xz .emacs.d/

    echo "<<< mv -f dot.emacs.d.tar.xz ${PUB_HTML_CLP_ARH} >>>"
    mv -f dot.emacs.d.tar.xz ${PUB_HTML_CLP_ARH}
}

cd_git_url ()
{
    make_repo_vars
    echo "<<< cd ${!URL_GIT} >>>"
    cd ${!URL_GIT}
}

cd_git_url () {
    log_colors
    make_repo_vars

    path="${!URL_GIT}"

    echo "${CYAN}üìÅ –ü–µ—Ä–µ—Ö–æ–¥ –≤ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é git-—Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏—è:${RESET}"
    echo "${GRAY}‚Ü≥ cd ${path}${RESET}"

    if [[ -d "$path" ]]; then
        cd "$path" || {
            echo "${RED}‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø–µ—Ä–µ–π—Ç–∏ –≤ ${path}${RESET}"
            return 1
        }
        echo "${GREEN}‚úÖ –ü–µ—Ä–µ—à–ª–∏ –≤: ${BOLD}$(pwd)${RESET}"
    else
        echo "${YELLOW}‚ö†Ô∏è –ü—É—Ç—å '${path}' –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç${RESET}"
        return 2
    fi
}

rm_rf_git ()
{
    echo "<<< rm -rf *.git >>>"
    rm -rf *.git
}

xz_git ()
{
    check_dir_git
    cd_git_url
    make_repo_vars
    
    if [[ `pwd` == "${!URL_GIT}" ]]
    then rm_rf_git
    fi
    for i in `ls ${!URL_XZ}/*.git.tar.xz`
    do tar -xvf $i
    done
}

reclone ()
{
# –î–ª—è –∫–∞—Ç–∞–ª–æ–≥–∞, —Å–æ–¥–µ—Ä–∂–∞—â–µ–≥–æ git-—Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–π –≤—ã–ø–æ–ª–Ω—è–µ—Ç:
#
# - –ø—Ä–æ–≤–µ—Ä–∫—É —Ç–æ–≥–æ, —á—Ç–æ –≤ git-—Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–∏ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç —Å—Å—ã–ª–∫–∞ –Ω–∞
# —É–¥–∞–ª–µ–Ω–Ω—ã–π git-—Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–π;
#
# - –≤ —Å–ª—É—á–∞–µ —É—Å–ø–µ—Ö–∞ –ø–µ—Ä–µ—Ö–æ–¥–∏—Ç –≤ –≤—ã—à–µ–ª–µ–∂–∞—â–∏–π –∫–∞—Ç–∞–ª–æ–≥, —É–¥–∞–ª—è–µ—Ç
# git-—Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–π –∏ –∑–∞—Ç–µ–º –æ—Å—É—â–µ—Å—Ç–≤–ª—è–µ—Ç –ø–æ–ø—ã—Ç–∫—É –µ–≥–æ –ø–æ–≤—Ç–æ—Ä–Ω–æ–≥–æ
# –∫–ª–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è.

### ToDo
### –î–æ–±–∞–≤–∏—Ç—å –≤—Ç–æ—Ä–æ–π –ø–∞—Ä–∞–º–µ—Ç—Ä - –∏–º—è —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏—è (–≤–º–µ—Å—Ç–æ pi).
### –î–æ–±–∞–≤–∏—Ç—å –ø—Ä–æ–≤–µ—Ä–∫—É, –Ω–∞ —Ç–æ —á—Ç–æ —É–¥–∞–ª–µ–Ω–Ω—ã–π —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–π —Å—É—â–µ—Å—Ç–≤—É–µ—Ç.
### !!!!!!!!!!

CDIR=`pwd`

PI=`git remote | grep pi`

if [[ ${PI} ==  ${NAME_pi} ]]
then
    BNAME=`basename ${CDIR}`
    echo ${BNAME}
    cd ../
    rm -rf ${BNAME}
    git clone $URL_GIT_pi/${BNAME}.git
    cd ${BNAME}
    git remote rename origin ${NAME_pi}
fi
}

add_aliases ()
{
    git config --global alias.lg 'log --oneline --graph'
    git config --global alias.co checkout
    git config --global alias.br branch
    git config --global alias.ci commit
    git config --global alias.st status
    git config --global alias.visual '!gitk'
    git config --global alias.tree '!git-tree'
    git config --global core.editor emacs
}

show_location_usage ()
{
    show_usage
    echo "–†–∞—Å–ø–æ–ª–æ–∂–µ–Ω–∏–µ –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑ —Å–ª–µ–¥—É—é—â–µ–≥–æ: [ ${LOCATIONS[*]} ]"
}

fgt ()
{
# –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–µ—Ä–µ–º–µ—Ç—Ä–æ–≤ –Ω–∞—á–∞–ª–æ
    if [ -z "$1" ]
    then
        show_usage
        exit 1
    else
        COMMAND=$1
        if [[ ${COMMAND} == "readd"             || \
                  ${COMMAND} == "update"        || \
                  ${COMMAND} == "rm"            || \
                  ${COMMAND} == "clone"         || \
                  ${COMMAND} == "remake_xz"     || \
                  ${COMMAND} == "remake_tar_xz" || \
                  ${COMMAND} == "xz_git"        || \
                  ${COMMAND} == "remake_git"    || \
                  ${COMMAND} == "make_git"      || \
                  ${COMMAND} == "info" ]]
        then
            if  [[ -z "$2" ]]
            then
                show_location_usage
                echo "–†–∞—Å–ø–æ–ª–æ–∂–µ–Ω–∏–µ –Ω–µ —É–∫–∞–∑–∞–Ω–æ."
                exit 1
            elif ! [[ -z "$2" ]]
            then
                LOCATION=$2
                GOOD_LOCATION='NO'
                for i in ${LOCATIONS[@]}
                do
                    if [[ ${LOCATION} == ${i} ]]
                    then
                        GOOD_LOCATION='YES'
                    fi
                done
                if ! [[ ${GOOD_LOCATION} == 'YES' ]]
                then
                    show_location_usage
                    exit 1
                fi                            
            fi 
        fi
    fi
# –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ –∫–æ–Ω–µ—Ü
    if [[ ${COMMAND} == "push"        || \
              ${COMMAND} == "pull"    || \
              ${COMMAND} == "pullsh"  || \
              ${COMMAND} == "add"     || \
              ${COMMAND} == "commit"  || \
              ${COMMAND} == "all"     || \
              ${COMMAND} == "readd"   || \
              ${COMMAND} == "update"  || \
              ${COMMAND} == "rm"      || \
              ${COMMAND} == "clone" ]]
    then
        tree_command
    elif [[ ${COMMAND} == "command" ]]
    then
        tree_command_1 $2 $3 $4 $5 $6 $7 $8 $9
    elif [[ ${COMMAND} == "remake_xz" ]]
    then
        remake_xz
    elif [[ ${COMMAND} == "remake_tar_xz" ]]
    then
        remake_tar_xz
    elif [[ ${COMMAND} == "xz_git" ]]
    then
        xz_git
    elif [[ ${COMMAND} == "remake_git" ]]
    then
        remake_git
    elif [[ ${COMMAND} == "make_git" ]]
    then
        make_git
    elif [[ ${COMMAND} == "info" ]]
    then
        info
    elif [[ ${COMMAND} == "quicklisp" ]]
    then
        rs_quicklisp
    elif [[ ${COMMAND} == "pacman" ]]
    then
        rs_pacman
    elif [[ ${COMMAND} == "dot_emacs_d" ]]
    then
        rs_dot_emacs_d_public
    elif [[ ${COMMAND} == "rs_local_pi" ]]
    then
        rsync -Pavzhe ssh --delete ${HOME}/public_html/ namatv@mnasoft.ddns.mksat.net:/usr/share/nginx/html
    elif [[ ${COMMAND} == "rs_pi_local" ]]
    then
        rsync -Pavzhe ssh --delete namatv@mnasoft.ddns.mksat.net:/usr/share/nginx/html/ ${HOME}/public_html
    elif [[ ${COMMAND} == "rs_pi_html" ]]
    then
        rsync -Pavzhe ssh --delete ~/public_html/Common-Lisp-Programs/ namatv@mnasoft.ddns.mksat.net:/usr/share/nginx/html/Common-Lisp-Programs/
    elif [[ ${COMMAND} == "reclone" ]]
    then
        reclone
    elif [[ ${COMMAND} == "add_aliases" ]]
    then
        add_aliases
    else
        echo "Unknown command: ${COMMAND}"
        show_usage
    fi
}

load_git_tree_config
init_location_vars
init_git_tree_structure
fgt "$@"
