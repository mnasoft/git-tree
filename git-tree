#!/bin/bash
<<<<<<< HEAD
# 
REPO_NAME_pp="pp"
REPO_NAME_pz="pz"
REPO_NAME_pi="pi"
REPO_NAME_or="origin"
REPO_NAME_pb="pb"
# 
REPO_GIT_URL_pp="$HOME/git"
REPO_GIT_URL_pz="$HOME/git-big"
REPO_GIT_URL_pi="git@mnasoft.ddns.mksat.net:/opt/git"
REPO_GIT_URL_or="//n000325/home/_namatv/_git"
REPO_GIT_URL_pb="//n133905/home/_namatv/git_pb"
# 
REPO_XZ_URL_pp="$HOME/xz"
REPO_XZ_URL_pz="$HOME/xz-big"
# 
REPO_XZ_TAR_pp="xz.tar"
REPO_XZ_TAR_pz="xz-big.tar"
=======
#
REPO_NAME_PP="pp"
REPO_NAME_PZ="pz"
REPO_NAME_PI="pi"
REPO_NAME_OR="origin"
# 
REPO_GIT_PP_URL="$HOME/git"
REPO_GIT_PZ_URL="$HOME/git-big"
REPO_GIT_PI_URL="git@mnasoft.ddns.mksat.net:/opt/git"
REPO_GIT_OR_URL="//n000325/home/_namatv/_git"
# 
REPO_XZ_PP_URL="$HOME/xz"
REPO_XZ_PZ_URL="$HOME/xz-big"
# 
REPO_XZ_PP_TAR="xz.tar"
REPO_XZ_PZ_TAR="xz-big.tar"
>>>>>>> 33d6c36b5efa90b942dba8a056863f3c7b7c37e3
#
PUB_HTML_CLP_ARH="$HOME/public_html/Common-Lisp-Programs/Archive"
#
VAR_CACHE_PACMAN="/var/cache/pacman"
VAR_LIB_PACMAN="/var/lib/pacman"
<<<<<<< HEAD
#   remake_git
=======
>>>>>>> 33d6c36b5efa90b942dba8a056863f3c7b7c37e3

echo_short ()
{
    # echo '--------------------'
    cd .
}

echo_long ()
{
    # echo '---------------------------------'
    cd .
}

echo_long_plus ()
{
    # echo '+++++++++++++++++++++++++++++++++'
    cd .
}

echo_long_equal ()
{
    echo '================================================================================'
}
####################################################################################################
#### check_dir
####################################################################################################

check_dir_public_html_clp_arch ()
{
    echo "<<< mkdir -p ${PUB_HTML_CLP_ARH} >>>"
    mkdir -p ${PUB_HTML_CLP_ARH}
}

<<<<<<< HEAD
check_dir_git ()
{
    REPO_GIT_URL="REPO_GIT_URL_${BRANCH}"
    echo "<<< mkdir -p ${!REPO_GIT_URL} >>>"
    mkdir -p ${!REPO_GIT_URL}
}

check_dir_xz ()
{
    REPO_XZ_URL="REPO_XZ_URL_${BRANCH}"
    echo "<<< mkdir -p ${!REPO_XZ_URL} >>>"    
    mkdir -p ${!REPO_XZ_URL}
}

rm_git ()
{
    REPO_GIT_URL="REPO_GIT_URL_${BRANCH}"
    echo "<<< rm -rf ${!REPO_GIT_URL}/*.git >>>"    
    rm -rf ${!REPO_GIT_URL}/*.git
}

remove_xz ()
{
    REPO_XZ_URL="REPO_XZ_URL_${BRANCH}"
    echo "<<< rm -f ${!REPO_XZ_URL}/*.git.tar.xz >>>"
    rm -f ${!REPO_XZ_URL}/*.git.tar.xz
}

make_git ()
{
    CDIR=`pwd`
    REPO_GIT_URL="REPO_GIT_URL_${BRANCH}"
    
    for i in `find . -name "*.git"`
    do
        cd $i/..
        if [[ `git remote | grep ${BRANCH}` ]]
=======
check_dir_git_pp ()
{
    echo "<<< mkdir -p ${REPO_GIT_PP_URL} >>>"
    mkdir -p ${REPO_GIT_PP_URL}
}

check_dir_git_pz ()
{
    echo "<<< mkdir -p ${REPO_GIT_PZ_URL} >>>"
    mkdir -p ${REPO_GIT_PZ_URL}
}

check_dir_xz_pp ()
{
    echo "<<< mkdir -p ${REPO_XZ_PP_URL} >>>"    
    mkdir -p ${REPO_XZ_PP_URL}
}

check_dir_xz_pz ()
{
    echo "<<< mkdir -p ${REPO_XZ_PZ_URL} >>>"
    mkdir -p ${REPO_XZ_PZ_URL}
}

####################################################################################################
#### remove_git
####################################################################################################

rm_git_pp ()
{
    echo "<<< rm -rf $REPO_GIT_PP_URL/*.git >>>"    
    rm -rf $REPO_GIT_PP_URL/*.git
}

rm_git_pz ()
{
    echo "<<< rm -rf $REPO_GIT_PZ_URL/*.git >>>"
    rm -rf $REPO_GIT_PZ_URL/*.git
}

remove_xz_pp ()
{
    echo "<<< rm -f $REPO_XZ_PP_URL/*.git.tar.xz >>>"
    rm -f $REPO_XZ_PP_URL/*.git.tar.xz
}

remove_xz_pz ()
{
    echo "<<< rm -f $REPO_XZ_PZ_URL/*.git.tar.xz >>>"
    rm -f $REPO_XZ_PZ_URL/*.git.tar.xz
}

####################################################################################################
#### make_git 
####################################################################################################

make_git_pp ()
{
    CDIR=`pwd`
    for i in `find . -name "*.git"`
    do
        cd $i/..
        if [[ `git remote | grep pp` ]]
>>>>>>> 33d6c36b5efa90b942dba8a056863f3c7b7c37e3
        then
            NAME=`pwd`
            BNAME=`basename $NAME`
            echo $i
            echo $NAME
            echo $BNAME
            cd ..
<<<<<<< HEAD
            echo "<<< git clone --bare $BNAME ${!REPO_GIT_URL}/$BNAME.git >>>"
            git clone --bare $BNAME ${!REPO_GIT_URL}/$BNAME.git
=======
            echo "<<< git clone --bare $BNAME $REPO_GIT_PP_URL/$BNAME.git >>>"
            git clone --bare $BNAME $REPO_GIT_PP_URL/$BNAME.git
>>>>>>> 33d6c36b5efa90b942dba8a056863f3c7b7c37e3
        else
            cd ..
        fi
        cd $CDIR
    done
}

<<<<<<< HEAD
remake_xz ()
{
    remove_xz
    check_dir_xz
    REPO_GIT_URL="REPO_GIT_URL_${BRANCH}"
    cd ${!REPO_GIT_URL}
=======
make_git_pz ()
{
    CDIR=`pwd`
    for i in `find . -name "*.git"`
    do
        cd $i/..
        if [[ `git remote | grep pz` ]]
        then
            NAME=`pwd`
            BNAME=`basename $NAME`
            echo $i
            echo $NAME
            echo $BNAME
            cd ..
            echo "<<< git clone --bare $BNAME $REPO_GIT_PZ_URL/$BNAME.git >>>"
            git clone --bare $BNAME $REPO_GIT_PZ_URL/$BNAME.git
        else
            cd ..
        fi
        cd $CDIR
    done
}

####################################################################################################
#### remake-xz 
####################################################################################################

remake_xz_pp ()
{
    remove_xz_pp
    check_dir_xz_pp
    cd $REPO_GIT_PP_URL
>>>>>>> 33d6c36b5efa90b942dba8a056863f3c7b7c37e3
    for i in `find . -name "*.git"`
    do
        BNAME=`basename $i`
        echo $i
        echo $BNAME
        echo "<<< tar -cvvJf $BNAME.tar.xz $BNAME/ >>>"
        tar -cvvJf $BNAME.tar.xz $BNAME/
<<<<<<< HEAD
        echo "<<< mv $BNAME.tar.xz ${!REPO_XZ_URL}/ >>>"
        mv $BNAME.tar.xz ${!REPO_XZ_URL}/
    done
}

remake_git ()
=======
        echo "<<< mv $BNAME.tar.xz $REPO_XZ_PP_URL/ >>>"
        mv $BNAME.tar.xz $REPO_XZ_PP_URL/
    done
}

remake_xz_pz ()
{
    remove_xz_pz   
    check_dir_xz_pz
    cd $REPO_GIT_PZ_URL
    for i in `find . -name "*.git"`
    do
        BNAME=`basename $i`
        echo $i
        echo $BNAME
        echo "<<< tar -cvvJf $BNAME.tar.xz $BNAME/ >>>"
        tar -cvvJf $BNAME.tar.xz $BNAME/
        echo "<<< mv $BNAME.tar.xz $REPO_XZ_PZ_URL/ >>>"
        mv $BNAME.tar.xz $REPO_XZ_PZ_URL/
    done
}

####################################################################################################
####
####################################################################################################

remake_git_pp ()
>>>>>>> 33d6c36b5efa90b942dba8a056863f3c7b7c37e3
{
    # Выполняет пересоздание каталога ~/git, наполняя его чистыми
    # репозиториями. Поиск репозиротиев ведется в каталогах:
    # ~/quicklisp/local-projects/; ~/develop/; ~/elisp/.

<<<<<<< HEAD
    rm_git

    echo "<<< cd ${HOME}/quicklisp/local-projects/ >>>"
    cd ${HOME}/quicklisp/local-projects/
    make_git

    echo "<<< cd ${HOME}/develop/ >>>"
    cd ${HOME}/develop/
    make_git

    echo "<<< cd ${HOME}/elisp/ >>>"
    cd ${HOME}/elisp/
    make_git
}

####################################################################################################
# remake_tar_xz
####################################################################################################

remake_tar_xz ()
=======
    rm_git_pp

    echo "<<< cd ${HOME}/quicklisp/local-projects/ >>>"
    cd ${HOME}/quicklisp/local-projects/
    make_git_pp

    echo "<<< cd ${HOME}/develop/ >>>"
    cd ${HOME}/develop/
    make_git_pp

    echo "<<< cd ${HOME}/elisp/ >>>"
    cd ${HOME}/elisp/
    make_git_pp
}

remake_git_pz ()
{
    # Выполняет пересоздание каталога ~/git, наполняя его чистыми
    # репозиториями. Поиск репозиротиев ведется в каталогах:
    # ~/quicklisp/local-projects/; ~/develop/; ~/elisp/.

    rm_git_pz

    echo "<<< cd ${HOME}/quicklisp/local-projects/ >>>"
    cd ${HOME}/quicklisp/local-projects/
    
    make_git_pz

    echo "<<< cd ${HOME}/develop/ >>>"
    cd ${HOME}/develop/
    
    make_git_pz

    echo "<<< cd ${HOME}/elisp/ >>>"
    cd ${HOME}/elisp/
    make_git_pz
}

####################################################################################################
# remake_xz_pp_tar
####################################################################################################

remake_xz_pp_tar ()
>>>>>>> 33d6c36b5efa90b942dba8a056863f3c7b7c37e3
{
    # Выполняет перенос в каталог ${PUB_HTML_CLP_ARH}/ архивов
    # git.tar.xz
    
    check_dir_public_html_clp_arch
<<<<<<< HEAD
    remake_xz

    REPO_GIT_URL="REPO_GIT_URL_${BRANCH}"
    echo "<<< cd ${!REPO_XZ_URL} >>>"
    cd ${!REPO_XZ_URL}

    REPO_XZ_TAR="REPO_XZ_TAR_${BRANCH}"
    echo "<<< tar -cvvf ${!REPO_XZ_TAR} *.git.tar.xz >>>"
    tar -cvvf ${!REPO_XZ_TAR} *.git.tar.xz
    
    echo "<<< mv -f ${!REPO_XZ_TAR} ${PUB_HTML_CLP_ARH} >>>"
    mv -f ${!REPO_XZ_TAR} ${PUB_HTML_CLP_ARH}
=======
    remake_xz_pp

    echo "<<< cd ${REPO_XZ_PP_URL} >>>"
    cd ${REPO_XZ_PP_URL}
    
    echo "<<< tar -cvvf ${REPO_XZ_PP_TAR} *.git.tar.xz >>>"
    tar -cvvf ${REPO_XZ_PP_TAR} *.git.tar.xz
    
    echo "<<< mv -f ${REPO_XZ_PP_TAR} ${PUB_HTML_CLP_ARH} >>>"
    mv -f ${REPO_XZ_PP_TAR} ${PUB_HTML_CLP_ARH}
}

remake_xz_pz_tar ()
{
    # Выполняет перенос в каталог ${PUB_HTML_CLP_ARH}/ архивов
    # git.tar.xz
    
    check_dir_public_html_clp_arch
    remake_xz_pz

    echo "<<< cd ${REPO_XZ_PZ_URL} >>>"
    cd ${REPO_XZ_PZ_URL}
    
    echo "<<< tar -cvvf ${REPO_XZ_PZ_TAR} *.git.tar.xz >>>"
    tar -cvvf ${REPO_XZ_PZ_TAR} *.git.tar.xz
    
    echo "<<< mv -f ${REPO_XZ_PZ_TAR} ${PUB_HTML_CLP_ARH} >>>"
    mv -f ${REPO_XZ_PZ_TAR} ${PUB_HTML_CLP_ARH}
>>>>>>> 33d6c36b5efa90b942dba8a056863f3c7b7c37e3
}

####################################################################################################
#### git_tree
####################################################################################################

GIT_TREE_USAGE="
NAME

        $(basename $0) выполняет однотипные операции над репозиториями
            git, расположенными в дереве каталогов.

SYNOPSIS
        $(basename $0) [ pull | push | pullsh | all [<branch>]] 
                       | [commit | add]
<<<<<<< HEAD
                       | [readd         [ pp | pz | pi | or | pb]]
                       | [rm            [ pp | pz | pi | or | pb]]
                       | [clone         [ pp | pz | pi | or | pb]]
                       | [make_git      [ pp | pz ]]
                       | [xz_git        [ pp | pz ]]
                       | [remake_git    [ pp | pz ]]
                       | [remake_tar_xz [ pp | pz ]]

        $(basename $0) [quicklisp] | [pacman] | [dot_emacs_d] | [add_aliases]
=======
                       | [readd_pp | readd_pz | readd_pi | readd_or] 
                       | [rm_pp | rm_pz | rm_pi | rm_or] 
                       | [clone_pp | clone_pz | clone_pi | clone_or ] 
                       | [make_git_pp | make_git_pz] 

        $(basename $0) [remake_git_pp | remake_git_pz] 
                       | [remake_xz_pp_tar | remake_xz_pz_tar] 
                       | [quicklisp] | [pacman] | [dot_emacs_d] | [add_aliases]
                       | [xz_git | xz_pp_git | xz_pz_git]
>>>>>>> 33d6c36b5efa90b942dba8a056863f3c7b7c37e3
                       | [rs_local_pi | rs_pi_local | rs_pi_html]
                       | [reclone]

DESCRIPTION
    Форма 1:
        Выполняет поиск репозиториев git, начиная с текущего
        каталога. Для каждого найденного репозитория git выполняет
        соответствующую команду.
    Форма 2:
        Выполняет сооветствующую команду.

OPTIONS 
        <branch> задает ветку, получаемую|отправляемую на удаленные
            сервера. Если не указана операция выполняется с текущей
            веткой.

COMMANDS
        pull      - получение изменений с сервера;
        push      - отправка изменений на сервер;
        pullsh    - получение и отправка изменений;
        add       - добавление изменений;
        commit    - фиксация изменений;
        all       - получение изменений с сервера, добавление изменений,
                    фиксация изменений, отправка изменений на сервер;

    Удаление и повторное добавление удаленного репозитория:
<<<<<<< HEAD
        readd     - в размещение [ pp | pz | pi | or | pb ];

    Удаление удаленного репозитория:
        rm        -  в размещение [ pp | pz | pi | or | pb ];

    Клонирование дерева репозиториев:
        clone     - в размещение [ pp | pz | pi | or | pb ];

    Создание чистых репозиториев git:
        make_git :
            $REPO_GIT_URL_pp для расположения pp;
            $REPO_GIT_URL_pz для расположения pz;

        remake_git - удаляет и создает повтроно для: расположения pp в
            каталоге $REPO_GIT_URL_pp; расположения pz в каталоге
            $REPO_GIT_URL_pz чистые репозитории git, находящиеся в
=======
        readd_pp      - pp;
        readd_pz      - pz;
        readd_pi      - pi;
        readd_or      - or;

    Удаление удаленного репозитория:
        rm_pp         -  pp;
        rm_pz         -  pz;
        rm_pi         -  pi;
        rm_or         -  or;

    Клонирование дерева репозиториев:
        clone_pp      - в размещение pp;
        clone_pz      - в размещение pz;
        clone_pi      - в размещение pi;
        clone_or      - в размещение or;

    Создание чистых репозиториев git:
        make_git_pp - $REPO_GIT_PP_URL для удаленного репозитория pp;
        make_git_pz - $REPO_GIT_PZ_URL для удаленного репозитория pz;

        remake_git_pp - удаляет и создает повтроно в каталоге
            $REPO_GIT_PP_URL чистые репозитории git, находящиеся в
>>>>>>> 33d6c36b5efa90b942dba8a056863f3c7b7c37e3
            каталогах:
            - ${HOME}/quicklisp/local-projects/;
            - ${HOME}/develop/;
            - ${HOME}/elisp/;

<<<<<<< HEAD
        remake_xz - удаляет и повторно создает:
            - для расположения pp в каталоге
            $REPO_XZ_URL_pp
            - для расположения pz в каталоге
            $REPO_XZ_URL_pz 
            архивы .tar.xz репозиториев git, находящихся в каталоге 
            $REPO_GIT_URL_pp;
            $REPO_GIT_URL_pz
            соответственно;

        remake_tar_xz :
            - для расположения pp создает архив ${REPO_XZ_TAR_pp} из
              файлов с расширением .git.tar.xz, находящихся в каталоге
              ${REPO_XZ_URL_pp};
            - для расположения pz создает архив ${REPO_XZ_TAR_pz} из
              файлов с расширением .git.tar.xz, находящихся в каталоге
              ${REPO_XZ_URL_pz}, и перемещает его в каталог
              ${PUB_HTML_CLP_ARH};

    Распаковка архивов git.tar.xz в каталоги с чистыми репозиториями
    для расположения:
=======
        remake_git_pz - удаляет и создает повтроно в каталоге
            $REPO_GIT_PZ_URL чистые репозитории git, 
            находящиеся в каталогах:
            - ${HOME}/quicklisp/local-projects/;
            - ${HOME}/develop/;
            - ${HOME}/elisp/;

        remake_xz_pp - удаляет и повторно создает в каталоге
            $REPO_XZ_PP_URL 
            архивы .tar.xz репозиториев git, находящихся в каталоге 
            $REPO_GIT_PP_URL;
    
        remake_xz_pz - удаляет и повторно создает в каталоге
            $REPO_XZ_PZ_URL 
            архивы .tar.xz репозиториев git, находящихся в каталоге 
            $REPO_GIT_PZ_URL;
    
        remake_xz_pp_tar - создает архив ${REPO_XZ_PP_TAR} из файлов 
            с расширением .git.tar.xz, находящихся в каталоге 
            ${REPO_XZ_PP_URL}, и перемещает его в каталог 
            ${PUB_HTML_CLP_ARH};
    
        remake_xz_pz_tar - создает архив ${REPO_XZ_PZ_TAR} из файлов 
            с расширением .git.tar.xz, находящихся в каталоге 
            ${REPO_XZ_PZ_URL}, и перемещает его в каталог 
            ${PUB_HTML_CLP_ARH};


    Распаковка архивов git.tar.xz в каталоги с чистыми репозиториями
    для расположения:
        xz_pp_git - pp;
        xz_pz_git - pz;
>>>>>>> 33d6c36b5efa90b942dba8a056863f3c7b7c37e3
        xz_git - pp и pp;
    
        quicklisp - создает в каталоге ${PUB_HTML_CLP_ARH} файл quicklisp.tar.xz,
            содержащий данные для обновления quicklisp;
    
        pacman - копирует в какалог ${PUB_HTML_CLP_ARH} пакетов и файлов
            синхронизации, необходимях для обновления msys2;
    
        dot_emacs_d - копирует в какалог ${PUB_HTML_CLP_ARH} файлов из
             каталога .emacs.d;
    
        add_aliases - добавляет аббревиатуры для запуска команд git.
"

func_git_tree_usage_show ()
{
    echo "${GIT_TREE_USAGE}"
}

func_git_tree_push ()
{
    for rpo in `git remote`
    do
        echo_short

        echo "<<< git push ${rpo} ${DO_BRANCH} >>>"
        git push ${rpo} ${DO_BRANCH}
        
        echo_short
    done
}

func_git_tree_pull ()
{
    for rpo in `git remote`
    do
        echo_short
        
        echo "<<< git pull ${rpo} ${DO_BRANCH} >>>"
        git pull ${rpo} ${DO_BRANCH}
        
        echo_short
    done
}

func_git_tree_add ()
{
    echo_short

    echo "<<< git add `find . -name "*.lisp" -o -name "*.org" -o -name "*.asd" -o -name "*.c*" -o -name "*.h*"` >>>"
    git add `find . -name "*.lisp" -o -name "*.org" -o -name "*.asd" -o -name "*.c*" -o -name "*.h*"`
# -o -name "*.scr" 
    
    echo_short
}

<<<<<<< HEAD
func_git_tree_readd ()
{
    echo_short
    REPO_NAME="REPO_NAME_${BRANCH}"
    REPO_GIT_URL="REPO_GIT_URL_${BRANCH}"
    
    echo "<<< git remote remove ${!REPO_NAME} >>>"
    git remote remove ${!REPO_NAME}
=======
func_git_tree_readd_pp ()
{
    echo_short
    
    echo "<<< git remote remove ${REPO_NAME_PP} >>>"
    git remote remove ${REPO_NAME_PP}
>>>>>>> 33d6c36b5efa90b942dba8a056863f3c7b7c37e3
    
    DIR_REPO=`pwd`
    REPO=`basename ${DIR_REPO}`
    
<<<<<<< HEAD
    echo "<<< git remote add ${!REPO_NAME} ${!REPO_GIT_URL}/${REPO}.git >>>"
    git remote add ${!REPO_NAME} ${!REPO_GIT_URL}/${REPO}.git
=======
    echo "<<< git remote add ${REPO_NAME_PP} ${REPO_GIT_PP_URL}/${REPO}.git >>>"
    git remote add ${REPO_NAME_PP} ${REPO_GIT_PP_URL}/${REPO}.git
>>>>>>> 33d6c36b5efa90b942dba8a056863f3c7b7c37e3
    
    echo_short
}

<<<<<<< HEAD
func_git_rm ()
{
    echo_short
    REPO_NAME="REPO_NAME_${BRANCH}"
    echo "<<< git remote remove ${!REPO_NAME} >>>"
    git remote remove ${!REPO_NAME}
    echo_short
}

func_git_clone ()
{
    if [[ `git remote | grep ${BRANCH}` ]]
    then
        REPO_NAME="REPO_NAME_${BRANCH}"
        REPO_GIT_URL="REPO_GIT_URL_${BRANCH}"
        
        NAME=`pwd`
        BNAME=`basename $NAME`
        echo "<<< git clone --bare . ${!REPO_GIT_URL}/${BNAME}.git >>>"
        git           clone --bare . ${!REPO_GIT_URL}/${BNAME}.git
=======
func_git_tree_readd_pz ()
{
    echo_short
    
    echo "<<< git remote remove ${REPO_NAME_PZ} >>>"
    git remote remove ${REPO_NAME_PZ}
    
    DIR_REPO=`pwd`
    REPO=`basename ${DIR_REPO}`
    
    echo "<<< git remote add ${REPO_NAME_PZ} ${REPO_GIT_PZ_URL}/${REPO}.git >>>"
    git remote add ${REPO_NAME_PZ} ${REPO_GIT_PZ_URL}/${REPO}.git
    
    echo_short
}

func_git_tree_readd_pi ()
{
    echo_short
    
    echo "<<< git remote remove ${REPO_NAME_PI} >>>"
    git remote remove ${REPO_NAME_PI}
    
    DIR_REPO=`pwd`
    REPO=`basename ${DIR_REPO}`
    
    echo "<<< git remote add ${REPO_NAME_PI} ${REPO_GIT_PI_URL}/${REPO}.git >>>"
    git remote add ${REPO_NAME_PI} ${REPO_GIT_PI_URL}/${REPO}.git
    
    echo_short
}

func_git_tree_readd_or ()
{
    echo_short
    
    echo "<<< git remote remove ${REPO_NAME_OR} >>>"
    git remote remove ${REPO_NAME_OR}
    
    DIR_REPO=`pwd`
    REPO=`basename ${DIR_REPO}`
    
    echo "<<< git remote add ${REPO_NAME_OR} ${REPO_GIT_OR_URL}/${REPO}.git >>>"
    git remote add ${REPO_NAME_OR} ${REPO_GIT_OR_URL}/${REPO}.git
    
    echo_short
}

func_git_rm_pp ()
{
    echo_short
    echo "<<< git remote remove ${REPO_NAME_PP} >>>"
    git remote remove ${REPO_NAME_PP}
    echo_short
}

func_git_rm_pz ()
{
    echo_short
    echo "<<< git remote remove ${REPO_NAME_PZ} >>>"
    git remote remove ${REPO_NAME_PZ}
    echo_short
}

func_git_rm_pi ()
{
    echo_short
    echo "<<< git remote remove ${REPO_NAME_PI} >>>"
    git remote remove ${REPO_NAME_PI}
    echo_short
}

func_git_rm_or ()
{
    echo_short
    echo "<<< git remote remove ${REPO_NAME_OR} >>>"
    git remote remove ${REPO_NAME_OR}
    echo_short
}

func_git_clone_pp ()
{
    if [[ `git remote | grep pp` ]]
    then
        NAME=`pwd`
        BNAME=`basename $NAME`
        echo "<<< git clone --bare . ${REPO_GIT_PP_URL}/${BNAME}.git >>>"
        git           clone --bare . ${REPO_GIT_PP_URL}/${BNAME}.git
    fi
    echo_short
}

func_git_clone_pz ()
{
    if [[ `git remote | grep pz` ]]
    then
        NAME=`pwd`
        BNAME=`basename $NAME`
        echo "<<< git clone --bare . ${REPO_GIT_PZ_URL}/${BNAME}.git >>>"
        git           clone --bare . ${REPO_GIT_PZ_URL}/${BNAME}.git
    fi
    echo_short
}

func_git_clone_pi ()
{
    if [[ `git remote | grep pi` ]]
    then
        NAME=`pwd`
        BNAME=`basename $NAME`
        echo "<<< git clone --bare . ${REPO_GIT_PI_URL}/${BNAME}.git >>>"
        git           clone --bare . ${REPO_GIT_PI_URL}/${BNAME}.git
    fi
    echo_short
}

func_git_clone_or ()
{
    if [[ `git remote | grep origin` ]]
    then
        NAME=`pwd`
        BNAME=`basename $NAME`
        echo "<<< git clone --bare . ${REPO_GIT_OR_URL}/${BNAME}.git >>>"
        git           clone --bare . ${REPO_GIT_OR_URL}/${BNAME}.git
>>>>>>> 33d6c36b5efa90b942dba8a056863f3c7b7c37e3
    fi
    echo_short
}

func_git_tree_commit ()
{
    echo_short
    echo "<<< git commit -a -m \"`date -u`\" >>>"
    git commit -a -m "`date -u`"
    echo_short
}

func_git_tree_push_or_pull ()
{
    for rpo in `git remote`
    do
        echo_short

        echo "<<< git ${COMMAND} ${rpo} ${DO_BRANCH} >>>"
        git ${COMMAND} ${rpo} ${DO_BRANCH}

        echo_short
    done
}

func_git_tree_command_branch ()
{
    CURRENT_BRANCH=`git branch --no-color | grep \*  | cut -d ' ' -f 2`
    if ! [[ -z "${BRANCH}" ]]
    then
        DO_BRANCH="${BRANCH}"
    else
        DO_BRANCH="${CURRENT_BRANCH}"
    fi
# pull          - получение изменений с сервера;
# push          - отправка изменений на сервер;
    if [[ ${COMMAND} == "push" || ${COMMAND} == "pull" ]]
    then
        func_git_tree_push_or_pull
    fi
# pullsh        - получение и отправка изменений;    
    if [[ ${COMMAND} == "pullsh" ]]
    then
        func_git_tree_pull
        func_git_tree_push
    fi
# add - добавление изменений;    
    if [[ ${COMMAND} == "add" ]]
    then
        func_git_tree_add
    fi
# commit        - фиксация изменений;    
    if [[ ${COMMAND} == "commit" ]]
    then
        func_git_tree_commit
    fi
# all           - получение изменений с сервера, добавление изменений,
#                 фиксация изменений, отправка изменений на сервер;
    if [[ ${COMMAND} == "all" ]]
    then
        func_git_tree_pull
        func_git_tree_add
        func_git_tree_commit
        func_git_tree_push
    fi
<<<<<<< HEAD
# readd         - удаление и повторное добавление удаленного
#                 репозитория;
    if [[ ${COMMAND} == "readd" ]]
    then
        func_git_tree_readd
    fi
# rm            - удаление удаленного репозитория;
    if [[ ${COMMAND} == "rm" ]]
    then
        func_git_rm
    fi
# clone          - клонирование дерева репозиториев;
    if [[ ${COMMAND} == "clone" ]]
    then
        func_git_clone
    fi    
=======
# readd_pp      - удаление и повторное добавление удаленного
#                 репозитория pp;
    if [[ ${COMMAND} == "readd_pp" ]]
    then
        func_git_tree_readd_pp
    fi
# readd_pz      - удаление и повторное добавление удаленного
#                 репозитория pz;
    if [[ ${COMMAND} == "readd_pz" ]]
    then
        func_git_tree_readd_pz
    fi
# readd_pi      - удаление и повторное добавление удаленного
#                 репозитория pi;
    if [[ ${COMMAND} == "readd_pi" ]]
    then
        func_git_tree_readd_pi
    fi
# readd_or      - удаление и повторное добавление удаленного
#                 репозитория origin;
    if [[ ${COMMAND} == "readd_or" ]]
    then
        func_git_tree_readd_or
    fi
# rm_pp         - удаление удаленного репозитория pp;
    if [[ ${COMMAND} == "rm_pp" ]]
    then
        func_git_rm_pp
    fi
# rm_pz         - удаление удаленного репозитория pz;
    if [[ ${COMMAND} == "rm_pz" ]]
    then
        func_git_rm_pz
    fi
# rm_pi         - удаление удаленного репозитория pi;    
if [[ ${COMMAND} == "rm_pi" ]]
    then
        func_git_rm_pi
    fi    
# rm_or         - удаление удаленного репозитория origin;
    if [[ ${COMMAND} == "rm_or" ]]
    then
        func_git_rm_or
    fi
# clone_pp - клонирование дерева репозиториев в расположение pp;    
    if [[ ${COMMAND} == "clone_pp" ]]
    then
        func_git_clone_pp
    fi
# clone_pz - клонирование дерева репозиториев в расположение pz;    
    if [[ ${COMMAND} == "clone_pz" ]]
    then
        func_git_clone_pz
    fi
# clone_pi - клонирование дерева репозиториев в расположение pi;     
    if [[ ${COMMAND} == "clone_pi" ]]
    then
        func_git_clone_pp
    fi
# clone_or - клонирование дерева репозиториев в расположение origin;    
    if [[ ${COMMAND} == "clone_or" ]]
    then
        func_git_clone_or
    fi
>>>>>>> 33d6c36b5efa90b942dba8a056863f3c7b7c37e3
}

func_git_tree_command ()
{
    CDIR=`pwd`
    for i in `find . -name ".git"`
    do
        echo_long_equal
        cd ${CDIR}/${i}/../
        echo "`pwd`"
        echo_long
        func_git_tree_command_branch
        echo_long_plus
    done
    cd ${CDIR}
}

####################################################################################################

func_rs_quicklisp ()
{
#   Выполняет перенос в каталог public файлов, необходимях для
#   обновления quicklisp.
    check_dir_public_html_clp_arch

    cd $HOME/quicklisp/dists
    tar -cvvJf quicklisp.tar.xz ./quicklisp/*.cdb ./quicklisp/*.txt ./quicklisp/archives/
    mv -f quicklisp.tar.xz ${PUB_HTML_CLP_ARH}
}

func_rs_pacman ()
{
    # Выполняет копирование в какалог ${PUB_HTML_CLP_ARH} пакетов и
    # файлов синхронизации, необходимях для обновления msys2.
    
    check_dir_public_html_clp_arch

    if [[ -d "${VAR_CACHE_PACMAN}" ]]
    then
        cd ${VAR_CACHE_PACMAN}
        tar -cvvJf pkg.tar.xz pkg/
        mv -f pkg.tar.xz ${PUB_HTML_CLP_ARH}
    fi

    if [[ -d "${VAR_CACHE_PACMAN}" ]]
    then
        cd ${VAR_LIB_PACMAN}
        tar -cvvJf sync.tar.xz sync/
        mv -f sync.tar.xz ${PUB_HTML_CLP_ARH}
    fi
}

func_rs_dot_emacs_d_public ()
{
    # Выполняет копирование в какалог ${PUB_HTML_CLP_ARH} файлов из
    # каталога .emacs.d.

    check_dir_public_html_clp_arch

    echo "<<< cd ${HOME} >>>"
    cd ${HOME}

    echo "<<< tar -cvvJf dot.emacs.d.tar.xz .emacs.d/ >>>"
    tar -cvvJf dot.emacs.d.tar.xz .emacs.d/

    echo "<<< mv -f dot.emacs.d.tar.xz ${PUB_HTML_CLP_ARH} >>>"
    mv -f dot.emacs.d.tar.xz ${PUB_HTML_CLP_ARH}
}

<<<<<<< HEAD
cd_git_url ()
{
    REPO_GIT_URL="REPO_GIT_URL_${BRANCH}"
    echo "<<< cd ${!REPO_GIT_URL} >>>"
    cd ${!REPO_GIT_URL}
=======
cd_git_pp_url ()
{
    echo "<<< cd $REPO_GIT_PP_URL >>>"
    cd $REPO_GIT_PP_URL
}

cd_git_pz_url ()
{
    echo "<<< cd $REPO_GIT_PZ_URL >>>"
    cd $REPO_GIT_PZ_URL
>>>>>>> 33d6c36b5efa90b942dba8a056863f3c7b7c37e3
}

rm_rf_git ()
{
    echo "<<< rm -rf *.git >>>"
    rm -rf *.git
}

<<<<<<< HEAD
xz_git ()
=======
xz_pp_git ()
>>>>>>> 33d6c36b5efa90b942dba8a056863f3c7b7c37e3
{
    # Распаковывает архивы git.tar.xz, содержащие репозитории git, в
    # каталоги с чистыми репозиториями для pp расположения.
    
<<<<<<< HEAD
    check_dir_git
    cd_git_url
    REPO_GIT_URL="REPO_GIT_URL_${BRANCH}"
    if [[ `pwd` == "${!REPO_GIT_URL}" ]]
    then rm_rf_git
    fi
    for i in `ls ${!REPO_XZ_URL}/*.git.tar.xz`
=======
    check_dir_git_pp
    cd_git_pp_url
    if [[ `pwd` == "$REPO_GIT_PP_URL" ]]
    then rm_rf_git
    fi
    for i in `ls ${REPO_XZ_PP_URL}/*.git.tar.xz`
>>>>>>> 33d6c36b5efa90b942dba8a056863f3c7b7c37e3
    do tar -xvf $i
    done
}

<<<<<<< HEAD
=======
xz_pz_git ()
{
    # Распаковывает архивы git.tar.xz, содержащие репозитории git, в
    # каталоги с чистыми репозиториями для pz расположения.
    
    check_dir_git_pz
    cd_git_pz_url
    if [[ `pwd` == "$REPO_GIT_PZ_URL" ]]
    then rm_rf_git
    fi
    for i in `ls ${REPO_XZ_PZ_URL}/*.git.tar.xz`
    do tar -xvf $i
    done
}

xz_git ()
{
    # Распаковывает архивы git.tar.xz, содержащие репозитории git, в
    # каталоги с чистыми репозиториями для pp и pz расположений.
    xz_pp_git
    xz_pz_git
}

>>>>>>> 33d6c36b5efa90b942dba8a056863f3c7b7c37e3
func_reclone ()
{
# Для каталога, содержащего git-репозиторий выполняет:
#
# - проверку того, что в git-репозитории существует ссылка на
# удаленный git-репозиторий;
#
# - в случае успеха переходит в вышележащий каталог, удаляет
# git-репозиторий и затем осуществляет попытку его повторного
# клонирования.

### ToDo
### Добавить второй параметр - имя репозитория (вместо pi).
### Добавить проверку, на то что удаленный репозиторий существует.


CDIR=`pwd`

REPO_PI=`git remote | grep pi`

<<<<<<< HEAD
if [[ ${REPO_PI} ==  ${REPO_NAME_pi} ]]
=======
if [[ ${REPO_PI} ==  ${REPO_NAME_PI} ]]
>>>>>>> 33d6c36b5efa90b942dba8a056863f3c7b7c37e3
then
    B_NAME=`basename $CDIR`
    echo $B_NAME
    cd ../
    rm -rf $B_NAME
<<<<<<< HEAD
    git clone $REPO_GIT_URL_pi/$B_NAME.git
    cd $B_NAME
    git remote rename origin ${REPO_NAME_pi}
=======
    git clone $REPO_GIT_PI_URL/$B_NAME.git
    cd $B_NAME
    git remote rename origin ${REPO_NAME_PI}
>>>>>>> 33d6c36b5efa90b942dba8a056863f3c7b7c37e3
fi
}

add_aliases ()
{
    git config --global alias.lg 'log --oneline --graph'
    git config --global alias.co checkout
    git config --global alias.br branch
    git config --global alias.ci commit
    git config --global alias.st status
    git config --global alias.visual '!gitk'
    git config --global alias.tree '!git-tree'
    git config --global core.editor emacs
}

####################################################################################################
#### func_git_tree
####################################################################################################

func_git_tree ()
{
    if ! [[ -z "$2" ]]
    then
        BRANCH=$2
        echo ${BRANCH}
    fi

    if [ -z "$1" ]
    then
        func_git_tree_usage_show
    else
        COMMAND=$1
        if [[ ${COMMAND} == "push"          || \
<<<<<<< HEAD
                  ${COMMAND} == "pull"      || \
=======
		  ${COMMAND} == "pull"      || \
>>>>>>> 33d6c36b5efa90b942dba8a056863f3c7b7c37e3
                  ${COMMAND} == "pullsh"    || \
                  ${COMMAND} == "add"       || \
                  ${COMMAND} == "commit"    || \
                  ${COMMAND} == "all"       || \
<<<<<<< HEAD
                  ${COMMAND} == "readd"     || \
                  ${COMMAND} == "rm"        || \
                  ${COMMAND} == "clone" ]]
=======
                  ${COMMAND} == "readd_pp"  || \
                  ${COMMAND} == "readd_pz"  || \
                  ${COMMAND} == "readd_pi"  || \
                  ${COMMAND} == "readd_or"  || \
                  ${COMMAND} == "rm_pp"     || \
                  ${COMMAND} == "rm_pz"     || \
                  ${COMMAND} == "rm_pi"     || \
                  ${COMMAND} == "rm_or"     || \
                  ${COMMAND} == "clone_pp"  || \
                  ${COMMAND} == "clone_pz"  || \
                  ${COMMAND} == "clone_pi"  || \
                  ${COMMAND} == "clone_or" ]]
	   
>>>>>>> 33d6c36b5efa90b942dba8a056863f3c7b7c37e3
        then
            func_git_tree_command
	elif [[ ${COMMAND} == "quicklisp" ]]
	then
	    func_rs_quicklisp
	elif [[ ${COMMAND} == "pacman" ]]
	then
	    func_rs_pacman
	elif [[ ${COMMAND} == "dot_emacs_d" ]]
	then
	    func_rs_dot_emacs_d_public
<<<<<<< HEAD
	elif [[ ${COMMAND} == "remake_git" ]]
	then
	    remake_git
	elif [[ ${COMMAND} == "remake_xz" ]]
	then
	    remake_xz
	elif [[ ${COMMAND} == "remake_tar_xz" ]]
	then
	    remake_tar_xz
        elif [[ ${COMMAND} == "xz_git" ]]
	then
	    xz_git
=======
	elif [[ ${COMMAND} == "remake_git_pp" ]]
	then
	    remake_git_pp
        elif [[ ${COMMAND} == "remake_git_pz" ]]
	then
	    remake_git_pz
	elif [[ ${COMMAND} == "remake_xz_pp" ]]
	then
	    remake_xz_pp
	elif [[ ${COMMAND} == "remake_xz_pz" ]]
	then
	    remake_xz_pz
	elif [[ ${COMMAND} == "remake_xz_pp_tar" ]]
	then
	    remake_xz_pp_tar
	elif [[ ${COMMAND} == "remake_xz_pz_tar" ]]
	then
	    remake_xz_pz_tar
        elif [[ ${COMMAND} == "xz_git" ]]
	then
	    xz_git
	elif [[ ${COMMAND} == "xz_pp_git" ]]
	then
	    xz_pp_git
        elif [[ ${COMMAND} == "xz_pz_git" ]]
	then
	    xz_pz_git
>>>>>>> 33d6c36b5efa90b942dba8a056863f3c7b7c37e3
	elif [[ ${COMMAND} == "rs_local_pi" ]]
	then
	    # Выполняет синхронизацию папки ~/public_html/ с
	    # mnasoft.ddns.mksat.net.
	    rsync -Pavzhe ssh --delete ${HOME}/public_html/ namatv@mnasoft.ddns.mksat.net:/usr/share/nginx/html	    
	elif [[ ${COMMAND} == "rs_pi_local" ]]
	then
	    # Синхронизация mnasoft.ddns.mksat.net с папкой ~/public_html.
	    rsync -Pavzhe ssh --delete namatv@mnasoft.ddns.mksat.net:/usr/share/nginx/html/ ${HOME}/public_html
	elif [[ ${COMMAND} == "rs_pi_html" ]]
	then
	    # Синхронизация папки ~/public_html/Common-Lisp-Programs/ с сервером mnasoft.ddns.mksat.net
	    rsync -Pavzhe ssh --delete ~/public_html/Common-Lisp-Programs/ namatv@mnasoft.ddns.mksat.net:/usr/share/nginx/html/Common-Lisp-Programs/
	elif [[ ${COMMAND} == "reclone" ]]
	then
            func_reclone
<<<<<<< HEAD
	elif [[ ${COMMAND} == "make_git" ]]
	then
            make_git
=======
	elif [[ ${COMMAND} == "make_git_pp" ]]
	then
            make_git_pp
	elif [[ ${COMMAND} == "make_git_pz" ]]
	then
            make_git_pz
>>>>>>> 33d6c36b5efa90b942dba8a056863f3c7b7c37e3
        elif [[ ${COMMAND} == "add_aliases" ]]
	then
            add_aliases
        else
            echo "Unknown command: ${COMMAND}"
            func_git_tree_usage_show
        fi
    fi
}

####################################################################################################
#### Main 
####################################################################################################

<<<<<<< HEAD
func_git_tree ${1} ${2}
=======
func_git_tree ${1} ${2} 
>>>>>>> 33d6c36b5efa90b942dba8a056863f3c7b7c37e3
