#!/bin/bash
#
REPO_NAME_PP="pp"
REPO_NAME_PZ="pz"
REPO_NAME_PI="pi"
REPO_NAME_OR="origin"
#
REPO_URL_GIT_PP="$HOME/git"
REPO_URL_GIT_PZ="$HOME/git-big"
REPO_URL_GIT_PI="git@mnasoft.ddns.mksat.net:/opt/git"
REPO_URL_GIT_OR="//n000325/home/_namatv/_git"
#
REPO_URL_XZ_PP="$HOME/xz"
REPO_URL_XZ_PZ="$HOME/xz-big"
#
REPO_XZ_TAR_PP="xz.tar"
REPO_XZ_TAR_PZ="xz-big.tar"
#
PUB_HTML_CLP_ARH="$HOME/public_html/Common-Lisp-Programs/Archive"
#
VAR_CACHE_PACMAN="/var/cache/pacman"
VAR_LIB_PACMAN="/var/lib/pacman"

func_git_tree_echo_short ()
{
    # echo '--------------------'
    cd .
}

func_git_tree_echo_long ()
{
    # echo '---------------------------------'
    cd .
}

func_git_tree_echo_long_plus ()
{
    # echo '+++++++++++++++++++++++++++++++++'
    cd .
}

func_git_tree_echo_long_equal ()
{
    echo '================================================================================'
}
####################################################################################################
#### func_clp_check_public
####################################################################################################

func_clp_check_public ()
{
    echo "<<< mkdir -p ${PUB_HTML_CLP_ARH} >>>"
    mkdir -p "${PUB_HTML_CLP_ARH}"
}

####################################################################################################
#### For remake-git-pp
####################################################################################################

func_remove_git_pp ()
{
    echo "<<< rm -rf $REPO_URL_GIT_PP/*.git >>>"    
    rm -rf $REPO_URL_GIT_PP/*.git
}

func_remove_git_pz ()
{
    echo "<<< rm -rf $REPO_URL_GIT_PZ/*.git >>>"
    rm -rf $REPO_URL_GIT_PZ/*.git
}

func_remake_git_pp ()
{
    CDIR=`pwd`
    for i in `find . -name "*.git"`
    do
        cd $i/..
        if [[ `git remote | grep pp` ]]
        then
            NAME=`pwd`
            BNAME=`basename $NAME`
            echo $i
            echo $NAME
            echo $BNAME
            cd ..
            git clone --bare $BNAME $REPO_URL_GIT_PP/$BNAME.git
        else
            cd ..
        fi
        cd $CDIR
    done
}

func_remake_git_pz ()
{
    CDIR=`pwd`
    for i in `find . -name "*.git"`
    do
        cd $i/..
        if [[ `git remote | grep pz` ]]
        then
            NAME=`pwd`
            BNAME=`basename $NAME`
            echo $i
            echo $NAME
            echo $BNAME
            cd ..
            git clone --bare $BNAME $REPO_URL_GIT_PZ/$BNAME.git
        else
            cd ..
        fi
        cd $CDIR
    done
}

func_remake_git_pp_all ()
{
    # Выполняет пересоздание каталога ~/git, наполняя его чистыми
    # репозиториями. Поиск репозиротиев ведется в каталогах:
    # ~/quicklisp/local-projects/; ~/develop/; ~/elisp/.

    func_remove_git_pp
    
    cd ${HOME}/quicklisp/local-projects/
    func_remake_git_pp

    cd ${HOME}/develop/
    func_remake_git_pp

    cd ${HOME}/elisp/
    func_remake_git_pp
}

####################################################################################################
#### remake-xz-pp
####################################################################################################

func_remake_xz_pp_all ()
{
    # ToDo Рассмотреть возможность объединения func_remake_xz_pp
    # func_remove_repo_xz_pz в функцию с тремя параметрами

    func_remove_repo_xz_pp
    func_remake_xz_pp
}

####################################################################################################
#### remake_xz_pz
####################################################################################################

func_remake_xz_pz_all ()
{
    # ToDo Рассмотреть возможность объединения func_remake_xz_pp
    # func_remove_repo_xz_pz в функцию с тремя параметрами

    func_remove_repo_xz_pz
    func_remake_xz_pz
}

####################################################################################################
# clp-xz-pp-public func_clp_xz_pp_public
####################################################################################################

func_clp_xz_pp_public ()
{
    # Выполняет перенос в каталог ${PUB_HTML_CLP_ARH}/ архивов
    # git.tar.xz
    
    func_clp_check_public    
    func_remake_xz_pp_all
    
    cd ${REPO_URL_XZ_PP}
    tar -cvvf ${REPO_XZ_TAR_PP} *.git.tar.xz
    mv -f ${REPO_XZ_TAR_PP} ${PUB_HTML_CLP_ARH}
}

func_clp_xz_pz_public ()
{
    # Выполняет перенос в каталог ${PUB_HTML_CLP_ARH}/ архивов
    # git.tar.xz
    
    func_clp_check_public
    func_remake_xz_pz_all
    
    cd ${REPO_URL_XZ_PZ}
    tar -cvvf ${REPO_XZ_TAR_PZ} *.git.tar.xz
    mv -f ${REPO_XZ_TAR_PZ} ${PUB_HTML_CLP_ARH}
}

####################################################################################################
#### remake-xz-pp
####################################################################################################

func_remove_repo_xz_pp ()
{
    rm -f $REPO_URL_XZ_PP/*.git.tar.xz
}

func_remake_xz_pp ()
{
    mkdir -p $REPO_URL_XZ_PP
    cd $REPO_URL_GIT_PP
    for i in `find . -name "*.git"`
    do
        BNAME=`basename $i`
        echo $i
        echo $BNAME
        tar -cvvJf $BNAME.tar.xz $BNAME/
        mv $BNAME.tar.xz $REPO_URL_XZ_PP/
    done
}

func_remove_repo_xz_pz ()
{
    rm -f $REPO_URL_XZ_PZ/*.git.tar.xz
}

func_remake_xz_pz ()
{
    mkdir -p $REPO_URL_XZ_PZ
    cd $REPO_URL_GIT_PZ
    for i in `find . -name "*.git"`
    do
        BNAME=`basename $i`
        echo $i
        echo $BNAME
        tar -cvvJf $BNAME.tar.xz $BNAME/
        mv $BNAME.tar.xz $REPO_URL_XZ_PZ/
    done
}

####################################################################################################
#### git_tree
####################################################################################################

GIT_TREE_USAGE="
Usage: 
   $(basename $0) COMMAND [BRANCH]
   $(basename $0) quicklisp
   $(basename $0) pacman
   $(basename $0) dot_emacs_d
   $(basename $0) remake_git_pp
   $(basename $0) remake_git_pz - недоопределена
   $(basename $0) remake_xz_pp
   $(basename $0) remake_xz_pz
   $(basename $0) clp_xz_pp
   $(basename $0) clp_xz_pz
   $(basename $0) xz_git

Command: 
        pull          - получение изменений с сервера;
        push          - отправка изменений на сервер;
        pullsh        - получение и отправка изменений;
        add           - добавление изменений;
        commit        - фиксация изменений;
        all           - получение изменений с сервера, добавление изменений,
                        фиксация изменений, отправка изменений на сервер;
           Удаление и повторное добавление удаленного репозитория:
        readd_pp      - pp;
        readd_pz      - pz;
        readd_pi      - pi;
        readd_or      - or;
           Удаление удаленного репозитория:
        rm_pp         -  pp;
        rm_pz         -  pz;
        rm_pi         -  pi;
        rm_or         -  or;
           Клонирование дерева репозиториев:
        clone_pp      - в размещение pp;
        clone_pz      - в размещение pz;
        clone_pi      - в размещение pi;
        clone_or      - в размещение or;

Описание:

         Выполняет поиск репозиториев git, начиная с текущего
         каталога. Для каздого из, найденных репозиториев выполняет
         команду COMMAND для всех удаленных репозиториев.

         Необязательный параметр BRANCH задает ветку,
         получаемую|отправляемую на удаленные сервера. Если он не
         задан синхронизируется текущая ветка.
"

func_git_tree_usage_show ()
{
    echo "${GIT_TREE_USAGE}"
}

func_git_tree_push ()
{
    for rpo in `git remote`
    do
        func_git_tree_echo_short
        echo ">>> git push ${rpo} ${DO_BRANCH} <<<"
        git push ${rpo} ${DO_BRANCH}
        func_git_tree_echo_short
    done
}

func_git_tree_pull ()
{
    for rpo in `git remote`
    do
        func_git_tree_echo_short
        echo ">>> git pull ${rpo} ${DO_BRANCH} <<<"
        git pull ${rpo} ${DO_BRANCH}
        func_git_tree_echo_short
    done
}

func_git_tree_add ()
{
    func_git_tree_echo_short
    echo '>>> git add `find . -name "*.lisp" -o -name "*.org" -o -name "*.asd"` <<<'
    git add `find . -name "*.lisp" -o -name "*.org" -o -name "*.asd"`
# -o -name "*.scr" 
    
    func_git_tree_echo_short
}

func_git_tree_readd_pp ()
{
    func_git_tree_echo_short
    echo ">>> git remote remove ${REPO_NAME_PP} <<<"
    git remote remove ${REPO_NAME_PP}
    DIR_REPO=`pwd`
    REPO=`basename ${DIR_REPO}`
    echo ">>> git remote add ${REPO_NAME_PP} ${REPO_URL_GIT_PP}/${REPO}.git <<<"
    git remote add ${REPO_NAME_PP} ${REPO_URL_GIT_PP}/${REPO}.git
    func_git_tree_echo_short
}

func_git_tree_readd_pz ()
{
    func_git_tree_echo_short
    echo ">>> git remote remove ${REPO_NAME_PZ} <<<"
    git remote remove ${REPO_NAME_PZ}
    DIR_REPO=`pwd`
    REPO=`basename ${DIR_REPO}`
    echo ">>> git remote add ${REPO_NAME_PZ} ${REPO_URL_GIT_PZ}/${REPO}.git <<<"
    git remote add ${REPO_NAME_PZ} ${REPO_URL_GIT_PZ}/${REPO}.git
    func_git_tree_echo_short
}

func_git_tree_readd_pi ()
{
    func_git_tree_echo_short
    echo ">>> git remote remove ${REPO_NAME_PI} <<<"
    git remote remove ${REPO_NAME_PI}
    DIR_REPO=`pwd`
    REPO=`basename ${DIR_REPO}`
    echo ">>> git remote add ${REPO_NAME_PI} ${REPO_URL_GIT_PI}/${REPO}.git <<<"
    git remote add ${REPO_NAME_PI} ${REPO_URL_GIT_PI}/${REPO}.git
    func_git_tree_echo_short
}

func_git_tree_readd_or ()
{
    func_git_tree_echo_short
    echo ">>> git remote remove ${REPO_NAME_OR} <<<"
    git remote remove ${REPO_NAME_OR}
    DIR_REPO=`pwd`
    REPO=`basename ${DIR_REPO}`
    echo ">>> git remote add ${REPO_NAME_OR} ${REPO_URL_GIT_OR}/${REPO}.git <<<"
    git remote add ${REPO_NAME_OR} ${REPO_URL_GIT_OR}/${REPO}.git
    func_git_tree_echo_short
}

func_git_rm_pp ()
{
    func_git_tree_echo_short
    echo ">>> git remote remove ${REPO_NAME_PP} <<<"
    git remote remove ${REPO_NAME_PP}
    func_git_tree_echo_short
}

func_git_rm_pz ()
{
    func_git_tree_echo_short
    echo ">>> git remote remove ${REPO_NAME_PZ} <<<"
    git remote remove ${REPO_NAME_PZ}
    func_git_tree_echo_short
}

func_git_rm_pi ()
{
    func_git_tree_echo_short
    echo ">>> git remote remove ${REPO_NAME_PI} <<<"
    git remote remove ${REPO_NAME_PI}
    func_git_tree_echo_short
}

func_git_rm_or ()
{
    func_git_tree_echo_short
    echo ">>> git remote remove ${REPO_NAME_OR} <<<"
    git remote remove ${REPO_NAME_OR}
    func_git_tree_echo_short
}

func_git_clone_pp ()
{
    if [[ `git remote | grep pp` ]]
    then
        NAME=`pwd`
        BNAME=`basename $NAME`
        echo ">>> git clone --bare . ${REPO_URL_GIT_PP}/${BNAME}.git <<<"
        git           clone --bare . ${REPO_URL_GIT_PP}/${BNAME}.git
    fi
    func_git_tree_echo_short
}

func_git_clone_pz ()
{
    if [[ `git remote | grep pz` ]]
    then
        NAME=`pwd`
        BNAME=`basename $NAME`
        echo ">>> git clone --bare . ${REPO_URL_GIT_PZ}/${BNAME}.git <<<"
        git           clone --bare . ${REPO_URL_GIT_PZ}/${BNAME}.git
    fi
    func_git_tree_echo_short
}

func_git_clone_pi ()
{
    if [[ `git remote | grep pi` ]]
    then
        NAME=`pwd`
        BNAME=`basename $NAME`
        echo ">>> git clone --bare . ${REPO_URL_GIT_PI}/${BNAME}.git <<<"
        git           clone --bare . ${REPO_URL_GIT_PI}/${BNAME}.git
    fi
    func_git_tree_echo_short
}

func_git_clone_or ()
{
    if [[ `git remote | grep origin` ]]
    then
        NAME=`pwd`
        BNAME=`basename $NAME`
        echo ">>> git clone --bare . ${REPO_URL_GIT_OR}/${BNAME}.git <<<"
        git           clone --bare . ${REPO_URL_GIT_OR}/${BNAME}.git
    fi
    func_git_tree_echo_short
}

func_git_tree_commit ()
{
    func_git_tree_echo_short
    echo '>>> git commit -a -m "`date -u`" <<<'
    git commit -a -m "`date -u`"
    func_git_tree_echo_short
}

func_git_tree_push_or_pull ()
{
    for rpo in `git remote`
    do
    func_git_tree_echo_short
    echo ">>> git ${COMMAND} ${rpo} ${DO_BRANCH} <<<"
    git ${COMMAND} ${rpo} ${DO_BRANCH}
    func_git_tree_echo_short
    done
}

func_git_tree_command_branch ()
{
    CURRENT_BRANCH=`git branch --no-color | grep \*  | cut -d ' ' -f 2`
    if ! [[ -z "${BRANCH}" ]]
    then
        DO_BRANCH="${BRANCH}"
    else
        DO_BRANCH="${CURRENT_BRANCH}"
    fi
# pull          - получение изменений с сервера;
# push          - отправка изменений на сервер;
    if [[ ${COMMAND} == "push" || ${COMMAND} == "pull" ]]
    then
        func_git_tree_push_or_pull
    fi
# pullsh        - получение и отправка изменений;    
    if [[ ${COMMAND} == "pullsh" ]]
    then
        func_git_tree_pull
        func_git_tree_push
    fi
# add - добавление изменений;    
    if [[ ${COMMAND} == "add" ]]
    then
        func_git_tree_add
    fi
# commit        - фиксация изменений;    
    if [[ ${COMMAND} == "commit" ]]
    then
        func_git_tree_commit
    fi
# all           - получение изменений с сервера, добавление изменений,
#                 фиксация изменений, отправка изменений на сервер;
    if [[ ${COMMAND} == "all" ]]
    then
        func_git_tree_pull
        func_git_tree_add
        func_git_tree_commit
        func_git_tree_push
    fi
# readd_pp      - удаление и повторное добавление удаленного
#                 репозитория pp;
    if [[ ${COMMAND} == "readd_pp" ]]
    then
        func_git_tree_readd_pp
    fi
# readd_pz      - удаление и повторное добавление удаленного
#                 репозитория pz;
    if [[ ${COMMAND} == "readd_pz" ]]
    then
        func_git_tree_readd_pz
    fi
# readd_pi      - удаление и повторное добавление удаленного
#                 репозитория pi;
    if [[ ${COMMAND} == "readd_pi" ]]
    then
        func_git_tree_readd_pi
    fi
# readd_or      - удаление и повторное добавление удаленного
#                 репозитория origin;
    if [[ ${COMMAND} == "readd_or" ]]
    then
        func_git_tree_readd_or
    fi
# rm_pp         - удаление удаленного репозитория pp;
    if [[ ${COMMAND} == "rm_pp" ]]
    then
        func_git_rm_pp
    fi
# rm_pz         - удаление удаленного репозитория pz;
    if [[ ${COMMAND} == "rm_pz" ]]
    then
        func_git_rm_pz
    fi
# rm_pi         - удаление удаленного репозитория pi;    
if [[ ${COMMAND} == "rm_pi" ]]
    then
        func_git_rm_pi
    fi    
# rm_or         - удаление удаленного репозитория origin;
    if [[ ${COMMAND} == "rm_or" ]]
    then
        func_git_rm_or
    fi
# clone_pp - клонирование дерева репозиториев в расположение pp;    
    if [[ ${COMMAND} == "clone_pp" ]]
    then
        func_git_clone_pp
    fi
# clone_pz - клонирование дерева репозиториев в расположение pz;    
    if [[ ${COMMAND} == "clone_pz" ]]
    then
        func_git_clone_pz
    fi
# clone_pi - клонирование дерева репозиториев в расположение pi;     
    if [[ ${COMMAND} == "clone_pi" ]]
    then
        func_git_clone_pp
    fi
# clone_or - клонирование дерева репозиториев в расположение origin;    
    if [[ ${COMMAND} == "clone_or" ]]
    then
        func_git_clone_or
    fi
}

func_git_tree_command ()
{
    CDIR=`pwd`
    for i in `find . -name ".git"`
    do
        func_git_tree_echo_long_equal
        cd ${CDIR}/${i}/../
        echo "`pwd`"
        func_git_tree_echo_long
        func_git_tree_command_branch
        func_git_tree_echo_long_plus
    done
    cd ${CDIR}
}

####################################################################################################

func_rs_quicklisp ()
{
#   Выполняет перенос в каталог public файлов, необходимях для
#   обновления quicklisp.
    func_clp_check_public

    cd $HOME/quicklisp/dists
    tar -cvvJf quicklisp.tar.xz ./quicklisp/*.cdb ./quicklisp/*.txt ./quicklisp/archives/
    mv -f quicklisp.tar.xz ${PUB_HTML_CLP_ARH}
}

func_rs_pacman ()
{
    # Выполняет копирование в какалог ${PUB_HTML_CLP_ARH} пакетов и
    # файлов синхронизации, необходимях для обновления msys2.
    
    func_clp_check_public

    if [[ -d "${VAR_CACHE_PACMAN}" ]]
    then
        cd ${VAR_CACHE_PACMAN}
        tar -cvvJf pkg.tar.xz pkg/
        mv -f pkg.tar.xz ${PUB_HTML_CLP_ARH}
    fi

    if [[ -d "${VAR_CACHE_PACMAN}" ]]
    then
        cd ${VAR_LIB_PACMAN}
        tar -cvvJf sync.tar.xz sync/
        mv -f sync.tar.xz ${PUB_HTML_CLP_ARH}
    fi
}

func_rs_dot_emacs_d_public ()
{
    # Выполняет копирование в какалог ${PUB_HTML_CLP_ARH} файлов из
    # каталога .emacs.d.

    func_clp_check_public

    cd ${HOME}
    tar -cvvJf dot.emacs.d.tar.xz .emacs.d/
    mv -f dot.emacs.d.tar.xz ${PUB_HTML_CLP_ARH}
}

func_xz_git ()
{
    mkdir -p "$REPO_URL_GIT_PP"
    cd "$REPO_URL_GIT_PP"
    if [[ `pwd` == "$REPO_URL_GIT_PP" ]]
    then
	rm -rf *.git
    fi
    for i in `ls ${REPO_URL_XZ_PP}/*.git.tar.xz`
    do tar -xvf $i
    done

    mkdir -p "$REPO_URL_GIT_PZ"
    cd "$REPO_URL_GIT_PZ"
    if [[ `pwd` == "$REPO_URL_GIT_PZ" ]]
    then
	rm -rf *.git
    fi
    for i in `ls ${REPO_URL_XZ_PZ}/*.git.tar.xz`
    do tar -xvf $i
    done
}

####################################################################################################
#### func_git_tree
####################################################################################################

func_git_tree ()
{
    if ! [[ -z "$2" ]]
    then
        BRANCH=$2
        echo ${BRANCH}
    fi

    if [ -z "$1" ]
    then
        func_git_tree_usage_show
    else
        COMMAND=$1
        if [[ ${COMMAND} == "push"          || \
		  ${COMMAND} == "pull"      || \
                  ${COMMAND} == "pullsh"    || \
                  ${COMMAND} == "add"       || \
                  ${COMMAND} == "commit"    || \
                  ${COMMAND} == "all"       || \
                  ${COMMAND} == "readd_pp"  || \
                  ${COMMAND} == "readd_pz"  || \
                  ${COMMAND} == "readd_pi"  || \
                  ${COMMAND} == "readd_or"  || \
                  ${COMMAND} == "rm_pp"     || \
                  ${COMMAND} == "rm_pz"     || \
                  ${COMMAND} == "rm_pi"     || \
                  ${COMMAND} == "rm_or"     || \
                  ${COMMAND} == "clone_pp"  || \
                  ${COMMAND} == "clone_pz"  || \
                  ${COMMAND} == "clone_pi"  || \
                  ${COMMAND} == "clone_or" ]]
	   
        then
            func_git_tree_command
	elif [[ ${COMMAND} == "quicklisp" ]]
	then
	    func_rs_quicklisp
	elif [[ ${COMMAND} == "pacman" ]]
	then
	    func_rs_pacman
	elif [[ ${COMMAND} == "dot_emacs_d" ]]
	then
	    func_rs_dot_emacs_d_public
	elif [[ ${COMMAND} == "remake_git_pp" ]]
	then
	    func_remake_git_pp_all
	    
	elif [[ ${COMMAND} == "remake_xz_pp" ]]
	then
	    func_remake_xz_pp_all
	elif [[ ${COMMAND} == "remake_xz_pz" ]]
	then
	    func_remake_xz_pz_all

	elif [[ ${COMMAND} == "clp_xz_pp" ]]
	then
	    func_clp_xz_pp_public
	elif [[ ${COMMAND} == "clp_xz_pz" ]]
	then
	    func_clp_xz_pz_public
	elif [[ ${COMMAND} == "xz_git" ]]
	then
	    func_xz_git
        else
            echo "Unknown command: ${COMMAND}"
            func_git_tree_usage_show
        fi
    fi
}


